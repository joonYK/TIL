# 객체지향 프로그래밍

객체지향 프로그래밍에 대한 설명으로 "실제 세계를 모델링 하는 새로운 방법" 이라 하지만 얼버무리는 수준에 지나지 않는다. <br/>
객체 지향을 설명할 때 캡슐화, 상속, 다형성의 세 가지 개념을 조합한 것이거나 반드시 지원해야 한다고도 한다. 한 가지 확실한 것은 다형성이란 특성를 다른 어떤 패러다임의 언어보다 안전하고 편리한 방법으로 제공한다는 것이다.

## 캡슐화

객체 지향 언어는 데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 제공한다고 생각한다.
그래서 데이터와 함수를 응집력 있게 구성하고 데이터는 은닉, 일부 함수만 노출되도록 한다.
하지만 이런 개념은 객체 지향에만 국한된 것은 아니다. 

### C 언어

캡슐화의 개념은 C 언어에서도 적용이 가능하다. 헤더 파일(.h)에 구조체와 함수의 형태를 정의하고, 구현 파일(.c)에 구조체의 멤버 변수와 함수를 구현한다. <br/>
해당 헤더 파일을 include 해서 사용하는 곳에서는 구조체의 멤버에 접근할 수 없고 함수 호출만이 가능하다. 그리고 데이터 구조가 어떻게 구성되어 있는지 함수가 어떻게 구현되어 있는지도 알 수 없다.

### C++ (C를 기반으로 한 객체지향 언어)

C++은 C가 제공하던 완전한 캡슐화를 제공하지 못한다. 컴파일러의 기술적 이유로 클래스의 멤버 변수를 해당 클래스의 헤더 파일에 선언할 것을 요구하는데, 해당 헤더 파일을 사용하는 측에서 멤버 변수가 어떻게 구성되어 있는지 알 수 있게 되기 때문이다.

### 자바, C#

헤더와 구현체를 분리하는 방식을 버려서 캡슐화가 더욱 심하게 훼손되었다. 그리고 많은 객체 지향 언어(스몰토크, 파이썬, 자바스크립트, 루비 등)가 캡슐화를 거의 강제하지 않는다.

### 정리

객체 지향 프로그래밍은 캡슐화된 데이터를 우회해서 사용하지 않을 거라는 믿음을 기반으로 한다.<br/>
하지만 객체 지향을 제공한다고 주창한 언어들이 C 언어에서 누렸던 완벽한 캡슐화를 약화시켜 온 것은 틀림없다.

## 상속

상속이란 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일에 불과하다. 그리고 객체 지향 언어가 없던 시대에도 이러한 방식으로 구현할 수 있었다.<br/>
하지만 상속을 흉내내는 요령이었지 사실상 상속만큼 편리한 방식은 절대 아니었다. 따라서 객체지향 언어가 완전히 새로운 개념을 만들진 못했지만 편리한 방식으로 제공했다고 볼 수는 있다.

## 다형성

다형성은 함수를 가리키는 포인터를 응용한 것이다. 하지만 함수 포인터를 사용해서 다형적 행위를 만들 때, 포인터를 직접 사용하여 만드는 방식은 위험하다.<br/>
이러한 기법은 여러 관례를 준수해야 하는데, 포인터를 초기화하고 포인터를 통해 모든 함수를 호출해야하는 관례를 지켜야 한다. 그렇지 않으면 버그가 발생하고, 버그를 찾고 제거하는것이 상당히 힘들다.<br/>
객체 지향 언어는 이런 관계를 없애주며 실수할 위험이 없다. 그래서 객체 지향 언어는 제어흐름을 간접적으로 전환하는 규칙을 부과한다고 할 수 있다.

### 다형성이 가진 힘

프로그램은 장치 독립적이야 한다. 프로그램이 장치에 의존적이면 똑같은 기능을 하는 프로그램이지만 장치별로 만들어줘야 하기 때문이다.<br/>
그래서 플러그인 아키텍처가 나왔는데, 그 예로 유닉스는 입출력 장치들을 플러그인 형태(드라이버)로 만들었고 각 장치들이 해당 플러그인의 규격에 맞도록 만들어진다면 어떤 장치든 사용이 가능하게 된다.<br/>
그리고 객체 지향의 등장으로 이 플러그인 아키텍처를 안전하고 편리하게 적용할 수 있게 되었다.

## 의존성 역전(dependency inversion)

### 전형적인 호출 트리

<img src="images/flow of control.jpeg">

main함수가 고수준 함수를 호출, 고수준 함수는 다시 중간 수준 함수를 호출, 중간 수준 함수는 다시 저수준 함수를 호출한다. 이러한 호출 트리에서 소스 코드 의존성의 방향은 반드시 제어흐름을 따르게 된다.

### 다형성을 적용

<img src="images/dependency inversion.jpeg">

* HL1 모듈은 ML1 모듈의 F() 함수를 호출.
* 소스 코드에서는 HL1 모듈은 인터페이스를 통해 F() 함수를 호출.
    * 이 인터페이스는 런타임에는 존재하지 않음.

위 그림에서 ML1과 I 인터페이스 사이의 소스 코드 의존성은 제어 흐름과 반대이다. 이를 의존성 역전이라 부르며 객체 지향 언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소스 코드 의존성을 어디에서든 역전시킬 수 있다는 뜻이기도 하다.<br/>
이렇게 함으로써 얻을 수 있는 이점의 예로 업무 규칙이 DB와 UI에 의존하는 대신에 시스템의 소스 코드 의존성을 반대로 배치하여 DB와 UI가 업무 규칙에 의존하게 만들 수 있다.<br/>
즉, UI와 DB가 업무 규칙의 플러그인이 되며, 업무 규칙의 소스 코드에서는 UI나 DB를 호출하지 않는다.<br/>
결과적으로 업무 규칙, UI, DB는 세 가지로 분리된 컴포넌트 또는 배포 가능한 단위로 컴파일이 가능해서 아래의 2가지 이점을 얻게 된다.

* 배포 독립성 : 특정 컴포넌트의 소스 코드가 변경되면, 해당 코드가 포함된 컴포넌트만 다시 배포하면 된다.
* 개발 독립성 : 시스템의 모듈을 독립적으로 배포할 수 있게 되면, 서로 다른 팀에서 각 모듈을 독립적으로 개발할 수 있다.

## 결론

소프트웨어 아키텍트의 관점에서 객체 지향이란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대항 절대적인 제어 권한을 획득할 수 있는 능력이다.<br/>
객체 지향을 사용하면 고수준의 모듈은 저수준에 대해 독립성을 보장할 수 있고, 저수준의 모듈은 고수준의 모듈과는 독립적으로 개발하고 배포할 수 있다.