# 완벽한 경계

아키텍처 경게를 완벽하게 만드는 것은 많은 비용이 든다.

### 완벽한 경계를 만드는데 필요한 것들

1. 쌍방향의 다형적 Boundary 인터페이스.
2. Input, Output을 위한 데이터 구조.
3. 두 영역을 독립적으로 컴파일하고 배포할 수 있는 컴포넌트 구조.
    * 그에 따른 필요한 모든 의존성에 대한 관리.

<img src="./images/부분적 경계_1.jpeg" width="50%">

### YAGNI(You Aren't Going to Neet it)

완벽한 경계를 만들고 유지하기 위해 많은 노력과 비용이 든다고 생각하지만, 혹시나 나중에 필요할지도 모른다는 생각을 가질 수 있다.

하지만 하지만 커뮤니티에서는 이런 선행적 설계를 "필요한 작업만 해라"는 YAGNI 원칙을 위배해서 좋게 보지 않는다. 그러나 이 경계를 포기할 수 없다면, 부분적 경계를 구현해볼 수 있다.

# 마지막 단계 건너뛰기

독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만드는데 필요한 작업을 모두 수행하고, 단일 컴포넌트에 그대로 모아서 컴파일과 배포를 한다.

* 완벽한 경계를 만들 때 만큼의 코드량과 사전 설계는 필요.
* 다수의 컴포넌트를 관리하는 작업은 하지 않아도 됨.
    * 버전, 배포 관리 등.

# 일차원 경계

완벽항 형태의 아키텍처 경계를 위해 양방향으로 격리된 상태를 유지하려면 초기 설정할 때나 지속적으로 유지할 때 비용이 많이 든다.

추후에 완벽한 형태의 경계로 확장 가능하도록 하는 간단한 구조를 사용할 수 있다.

<img src="./images/부분적 경계_2.jpeg" width="50%">

* 전통적인 전략 패턴.
* 미래에 필요한 아키텍처 경계 구조를 마련해놓음.
* 쌍방향 인터페이스는 없음.
* Client와 ServiceImpl간의 점섬과 같은 비밀 통로가 생길 위험이 있음.

# 퍼사드

훨씬 더 단순한 경계로 퍼사드 패턴을 사용할 수 있다. 이 경우는 의존성 역전까지도 희생한다.

<img src="./images/부분적 경계_3.jpeg" width="50%">

* 경계는 Facade 클래스로만 간단히 정의.
* Facade 클래스에 모든 서비스 클래스를 메서드 형태로 정의.
* Client가 모든 서비스 클래스에 대해 추이 종속성을 가지게 됨.
    * 정적 언어라면 서비스 클래스 중 하나에서 소스 코드 변경시 Client도 무조건 재컴파일 필요.