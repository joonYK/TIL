# 아키텍처

아키텍처란 시스템을 구축했던 사람들이 만들어낸 시스템의 형태이며 시스템을 컴포넌트로 분할하는 방법, 분할된 컴포넌트를 배치하는 방법, 컴포넌트가 서로 의사소통 하는 방식에 따라 정해진다. 그리고 그 형태는 쉽게 개발, 배포, 운영, 유지보수하도록 만들어진다.

## 아키텍처의 목표

아키텍처의 주된 목적은 시스템의 동작 여부보다는 시스템의 생명주기를 지원하는 것이다. 형편없는 아키텍처를 갖춘 시스템도 동작은 하지만 배포, 유지보수에서 어려움을 겪게 된다. 그래서 좋은 아키텍처는 시스템을 쉽게 이해하고 쉽게 개발, 쉽게 유지보수, 쉽게 배포하게 해준다. 즉, 궁극적인 목표는 시스템의 수명과 관련된 비용은 최소화하고 프로그래머의 생산성은 최대화하는 데 있다.

## 아키텍트

아키텍처를 설계하는 아키텍트는 최고의 프로그래머이며, 앞으로도 계속 프로그래밍 작업을 맡을 뿐만 아니라 나머지 팀원들이 생산성을 극대화할 수 있는 설계를 하도록 방향을 이끌어 준다. 그래서 아키텍트는 오히려 코드와 멀어져서는 안 된다. 프로그래밍을 손에서 놓게 된다면, 여러가지 발생하는 문제를 경험해보지 못해 다른 프로그래머를 지원하는 작업을 제대로 수행할 수 없기 때문이다.

## 개발

개발하기 힘든 시스템은 수명이 길거나 건강하지 못한 시스템이 될 것이다. 그래서 아키텍처는 개발팀(들)이 시스템을 쉽게 개발할 수 있도록 뒷받침해야만 한다.

## 배포

소프트웨어 시스템이 사용되려면 반드시 배포되어야 하며, 배포 비용이 높을수록 시스템의 유용성은 떨어진다. 따라서 아키텍처는 시스템을 단 한 번에 쉽게 배포할 수 있또록 만드는 데 그 목표를 두어야 한다.<br/>
그러나 개발 초기 단계에는 배포 전략을 거의 고려하지 않는데, 개발하기엔 쉽더라도 배포하기엔 어려운 아키텍처가 만들어지는 경우가 많다.

## 운영

아키텍처가 시스템 운영에 미치는 영향은 개발, 배포, 유지보수에 미치는 영향보다는 적다. 운영에서 겪는 대다수의 어려움은 단순히 하드웨어를 투입해서 해결할 수 있기 때문이다. 그러나 좋은 아키텍처는 시스템을 운영하는 데 필요한 요구를 알려준다. 즉, 개발자에게 시스템의 운영 방식을 잘 드러내 준다고 할 수 있다.<br/>
따라서 아키텍처는 유스케이스, 기능, 시스템의 필수 행위를 일급(first-class) 엔티티로 격상시키고, 이들 요소가 개발자에게 주요 목표로 인식 되도록 해야 한다. 그래서 시스템을 이해하기 쉬워지고 그에 따라 개발과 유지보수에 큰 도움이 될 것이다.

## 유지보수

유지보수는 소프트웨어 시스템에서 비용이 가장 많이 든다. 끝없는 새로운 기능 개발, 뒤따라오는 결함에 대한 수정에 엄청난 인적 자원이 소모되기 때문이다.

### 유지보수의 가장 큰 비용 : 탐사(spelunking)

탐사는 새로운 기능을 추가하거나 결함을 수정할 때, 소프트웨어의 어디를 고치는게 최선인지, 어떤 전략을 쓰는게 최적일지 결정할 때 드는 비용이다. 변경사항 반영시에도 의도치 않은 결함이 발생할 수 있어서 이로 인한 위험부담 비용이 추가된다.

### 비용을 줄이는 방법

주의를 기울여 신중하게 아키텍처를 만들면 비용을 크게 줄일 수 있다. 시스템을 컴포넌트로 분리하고, 안정된 인터페이스를 두어 서로 격리하면 추가될 기능에 대비하고 의도치 않은 결함을 크게 줄일 수 있다.

## 선택사항 열어 두기

소프트웨어를 부드럽게 유지하는 방법은 중요하지 않은 세부사항에 대해 가능한 오랫동안 열어두는 것이다. 이런 세부사항에는 입출력 장치, DB, 웹 시스템, 웹서버, 프레임워크, 통신 프로토콜 등이 있다.<br/>
그래서 아키텍트의 목표는 정책을 가장 핵심적인 요소로 식별하고, 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는 것이다. 그러면 세부사항에 대해 결정을 오랫동안 미루거나 연기할 수 있다.<br/>
선택사항을 오랫동안 열어 둘 수 있다면 더 많은 실험과 시도를 해볼 수 있고, 더 많은 정보를 얻어서 이를 기초로 제대로 된 결정을 내릴 수 있다.

### 장치 독립성

오늘날의 운영체체는 입출력 장치를 소프트웨어 함수로 추상화했고, 해당 함수는 천공카드와 같은 단위 레코드를 처리한다. 프로그램은 운영체제의 서비스를 호출하고, 해당 서비스가 추상화된 단위 레코드 장치를 처리한다. 그리고 오퍼레이터가 해당 추상 서비스를 카드 판독기, 자기 테이프, 아니면 또 다른 단위 레코드 장치 중 어디에 연결해야 하는지 운영체제에 알려준다. 따라서 동일한 프로그램을 아무런 변경 없이 카드나 테이프에서 읽고 쓸 수 있게 되었다.


## 결론

좋은 아키텍트는 세부사항을 정책으로부터 신중하게 가려내고, 정책이 세부사항과 결합되지 않도록 엄격하게 분리한다. 그리고 세부사항에 대한 결정을 가능한 오래 미룰 수 있는 방향으로 정책을 설계한다. 이를 통해 정책은 세부사항에 의존하지 않게 된다. 
