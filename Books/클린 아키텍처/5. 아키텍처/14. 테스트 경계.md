테스트는 시스템의 일부이며, 아키텍처에도 관여한다.

# 시스템 컴포넌트인 테스트

아키텍처적으로 테스트가 갖는 여러 특징이 존재한다. 그리고 단위 테스트나 통합 테스트 등 모든 테스트는 아키텍처적으로 모두 동등하다. 

## 테스트는 의존성 규칙을 따름

테스트는 세부적이며 구체적인 것으로, 의존성은 항상 테스트 대상이 되는 코드를 향한다. 그리고 테스트는 아키텍처에서 가장 바깥족 원으로 생각할 수 있다.

* 시스템 내부의 어떤 것도 테스트에 의존하지 않음.
* 테스트는 시스템의 컴포넌트를 향해, 항상 원의 안쪽으로 의존.

## 테스트는 독립적으로 배포 가능

대다수의 경우 테스트는 테스트 시스템에만 배포하고 상용 시스템에는 배포하지 않는다. 이는 배포 독립성이 달리 필요하지 않은 시스템에서도 적용된다.

## 시스템 컴포넌트 중에서 가장 고립되어 있음

테스트는 시스템 운영에 꼭 필요하지 않고, 어떤 사용자도 테스트에 의존하지 않는다. 

* 테스트의 역할은 운영이 아닌 개발을 지원하는 데 있음.

<br/>

# 테스트를 고려한 설계

테스트가 지닌 극단적인 고립성과 대체로 배포하지 않는다는 사실에 의해 테스트가 시스템의 설계 범위 밖에 있다고 생각할 수 있다. 그러나 테스트가 시스템의 설계와 잘 통합되지 않으면, 테스트는 깨지기 쉬워지고 시스템은 뻣뻣해져서 변경하기 어려워진다.

* 시스템에 강하게 결합된 테스트는 시스템이 변경될 때 함께 변경되어야 함.
* 시스템 컴포넌트의 사소한 변경에도 결합된 수많은 테스트가 망가질 수 있음.
* 간단한 변경이 대량의 테스트로 이어질 수 있기 때문에, 변경 작업을 최대한 하지 않게 됨.

이 문제를 해결하려면 테스트를 고려한 설계가 필요하다.

## 변동성에 의존하지 않는 설계

테스트와 상관없이 소프트웨어 설계에 있어 변동성에 의존하지 않도록 설계하는 것은 아주 중요하다. 예를 들어, GUI 같은 경우는 변동성이 크다. 그래서 시스템과 테스트를 설계할 때, GUI를 사용하지 않고 업무 규칙을 테스트할 수 있게 해야 한다.

이를 위해 테스트가 모든 업무 규칙을 검증하는 데 사용할 수 있도록 특화된 테스트 API를 만들면 된다.

## 테스트 API

테스트를 애플리케이션으로 분리할 목적으로 사용한다. 단순히 테스트와 UI를 분리하는것이 아닌, 테스트 구조를 애플리케이션 구조로부터 결합을 분리하는것이 목표이다.

### 구조적 결합

구조적 결합이 생기면 상용 클래스나 메서드 중 하나라도 변경될 시, 다수의 테스트가 변경되어야 한다. 그래서 테스트는 깨지기 쉬워지고, 이로 인해 상용 코드를 뻣뻣하게 만든다.

* 모든 상용 클래스에 테스트 클래스가, 모든 상용 메서드에 테스트 메서드 집합이 각각 존재하는 경우.

### 테스트 API의 역할

애플리케이션의 구조를 테스트로부터 숨기는 데 있다. 이를 통해 상용 코드나 테스트의 변경이 서로에게 전혀 영향을 주지 않게 되고, 각자 따로 진화가 가능하게 된다.

* 시간이 지날수록 테스트는 더 구체적이고 더 특화된 형태로 변함.
* 시간이 지날수록 상용 코드는 더 추상적이고 더 범용적인 형태로 변함.

### 보안

테스트 API가 지닌 강력한 힘을 운영 시스템에 배포하면 위험에 처할 수 있다.

* 테스트 API 자체와 테스트 API 중 위험한 부분의 구현부는 독립적으로 배포.

<br/>

# 결론

테스트는 시스템의 일부다. 따라서 테스트에서 기대하는 안정성과 회귀의 이점을 얻으려면 잘 설계돼야만 한다. 