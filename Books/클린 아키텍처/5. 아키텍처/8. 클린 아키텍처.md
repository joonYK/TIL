# 관심사의 분리

지난 수십 년간 시스템 아키텍처와 관련된 여러 아이디어가 나왔다. 이들 아키텍처는 세부적인 내용에 다소 차이가 있지만, 관심사의 분리라는 공통적인 목표를 갖고 있다.<br/>
이 관심사의 분리는 최소한 업무 규칙을 위한 계층 하나와, 사용자와 시스템 인터페이스를 위한 또 다른 계층 하나를 반드시 포함한다.

## 특징

### 1. 프레임워크 독립성

* 프레임워크에 의존하지 않음.
* 프레임워크가 지닌 제약사항 안에 시스템을 가두지 않음.

### 2. 테스트 용이성

* 업구 규칙은 외부 요소(UI, DB, 웹 서버 등) 없이도 테스트 가능.

### 3. UI 독립성

* 시스템의 나머지 부분을 변경하지 않고도 UI를 쉽게 변경.
    * 업무 규칙의 변화 없이 웹 UI를 콘솔 UI로 변경.

### 4. 데이터베이스 독립성

* 업무 규칙이 DB에 결합되지 않음.

### 5. 모든 외부 에이전시에 대한 독립성

* 업무 규칙은 외부 세계와의 인터페이스에 대해 전혀 알지 못함.

<br/>

# 의존성 규칙

아래 그림은 관심사의 분리를 실현하고자 하는 아이디어에 대한 다이어그램이다. 각각의 동심원은 소프트웨어에서 서로 다른 영역을 표현하고 안으로 들어갈수록 수준의 소프트웨어이다. 이러한 아키텍처가 동작하도록 하는 가장 중요한 규칙은 의존성 규칙이다.

<img src="./images/클린 아키텍처_1.jpeg" width="80%">

* 소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책으로 향해야 함.
* 내부의 원은 외부의 원에 속한 어떤 것도 알지 못함.
    * 함수, 클래스, 변수 등.
* 외부 원에 위치한 어떤 것도 내부의 원에 영향을 주지 않아야 함.

## 엔티티

엔티티는 전사적인 핵심 업무 규칙을 캡슐화한다. 엔티티는 메서드를 가지는 객체이거나 일련의 데이터 구조와 함수의 집합일 수도 있는데, 기업의 다양한 애플리케이션에서 재사용 가능하다면 그 형태는 중요치 않다.

## 유스케이스

애플리케이션에 특화된 업무 규칙을 포함한다. 

* 엔티티로 들어오고 나가는 데이터 흐름을 조정.
* 엔티티가 자신의 핵심 업무 규칙을 사용해서 유스케이스의 목적을 달성하도록 이끔.
* 운영 관점에서 애플리케이션이 변경되면 유스케이스는 영향을 받음.

## 인터페이스 어댑터

어댑터는 데이터를 유스케이스와 엔티티에게 가장 편리한 형식에서 DB나 웹 같은 외부 에이전시에게 가장 편리한 형식으로 변환한다. 그리고 그 반대의 변환 또한 담당한다.

## 프레임워크와 드라이버

가장 바깥쪽 계층은 DB나 프레임워크같은 도구들로 구성된다.

* 안쪽 원과 통신하기 위한 접합 코드만 있으면 됨.
* 모든 세부사항이 위치하는 곳으로 이러한 것들을 모두 외부에 위치시켜 피해를 최소화.

## 경계 횡단하기

<img src="./images/클린 아키텍처_2.jpeg">

* 제어 흐름은 컨트롤러에서 유스케이스를 지난 후, 프레젠터에서 실행.
* 의존성은 유스케이스를 향해 안쪽을 가리킴.
* 제어흐름과 의존성의 방향이 반대이며, 의존성 역전 원칙으로 해결.

### 의존성 역전 원칙 적용

* 유스케이스에서 프레젠터를 호출할 때, 직접 호출하지 않음.
* 유스케이스가 내부 원의 인터페이스(유스케이스 출력 포트)를 호출하도록 하고, 외부 원의 프레젠터가 구현하도록 함.

### 경계를 횡단하는 데이터의 모습

* 데이터 구조는 간단한 데이터 구조.
    * DTO, 간단한 인자, 해시맵 등.
* 엔티티 객체나 데이터베이스의 행을 전달하지 말아야 함.
* 경계를 가로질러 데이터를 전달할 때, 데이터는 항상 내부의 원에서 사용하기에 가장 편리한 형태를 취함.

<br/>

# 전형적인 시나리오

아래 그림은 웹 기반 자바 시스템의 전형적인 시나리오에 대한 다이어그램이다.

<img src="./images/클린 아키텍처_3.jpeg" width="70%">

1. 입력 데이터를 controller로 전달.
2. controller는 입력 데이터를 자바 객체로 변환해서 InputBoundary 인터페이스를 통해 UseCaseInteractor로 전달.
3. UseCaseInteractor는 데이터를 해석해서 Entities의 업무 규칙을 실행.
    * DataAccessInterface를 사용해서 Entities가 사용할 데이터를 DB에서 불러와서 메모리에 로드.
4. UseCaseInteractor는 Entities로부터 데이터를 모아 OutputData를 구성.
5. OutputData는 OutputBoundary 인터페이스를 통해 Presenter로 전달.
6. Presenter는 OutputData를 ViewModel과 같이 화면에 출력할 수 있는 형식으로 재구성.
    * Currency나 Date 객체 같은 것들을 사용자가 보기에 적절한 문자열로 변환.
    * Button과 MenuItem의 이름을 포함하며 비활성화 여부 관련 플래그도 포함.

<br/>

# 결론

소프트웨어를 계층으로 분리하고 의존성 규칙을 준수하면 테스트하기 쉬운 시스템을 만들 수 있고, 시스템의 외부 요소(DB, 프레임워크)가 구식이 되더라도 쉽게 교체할 수 있다.
