# 업무 규칙

업무 규칙은 **사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차**이다. 컴퓨터상의 구현 여부와 상관없이, 사업적으로 수익을 얻거나 비용을 줄일 수 있어야한다.

## 업무 규칙 예시

* 대출에 이자를 부과하는 것은 은행이 돈을 버는 업무 규칙.
    * 프로그램으로 이자를 계산하든, 직원이 직접 계산하든 관계가 없음.
* 이러한 규칙을 **핵심 업무 규칙**이라 지칭.

## 핵심 업무 규칙

* 사업 자체에 핵심적이며, 규칙을 자동화하는 시스템이 없더라도 그대로 존재하는 업무 규칙.
* 핵심 업무 규칙은 보통 데이터를 요구.
    * 대출에는 대출 잔액, 이자율, 지급 일정이 필요.
    * 이러한 데이터를 **핵심 업무 데이터**라 지칭.

## 핵심 업무 데이터

* 시스템으로 자동화되지 않은 경우에도 존재할 수 있는 데이터.

## 엔티티

* 핵심 규칙과 핵심 데이터는 결합되어 객체(엔티티)로 표현할 수 있는 좋은 후보가 됨.

<br/>

# 엔티티

컴퓨터 시스템 내부의 객체로, 핵심 업무 데이터를 기반으로 동작하는 일련의 조그만 핵심 업무 규칙을 구체화 한다.

* 핵심 업무 데이터를 직접 포함하거나 핵심 업무 데이터에 쉽게 접근 가능.
* 엔티티의 인터페이스는 핵심 업무 데이터를 기반으로 동작하는 핵심 업무 규칙을 구현한 함수들로 구성.

## 독립적인 존재

* 엔티티는 DB, UI, 서드파티 프레임워크에 대한 고려사항들로 오염되어서는 안 됨.
* 어떤 시스템에서도 업무를 수행 가능해야 함.
* 엔티티는 순전히 업무에 대한 것이며, 이외의 것은 없음.

## 모듈

* 엔티티를 만드는 데 꼭 객체 지향 언어를 사용할 필요는 없음.
* 핵심 업무 데이터와 핵심 업무 규칙을 하나로 묶어서 별도의 소프트웨어 모듈로 만들어야 한다는것이 핵심.

<br/>

# 유스케이스

자동화된 시스템이 동작하는 방법을 정의하고 제약함으로써 수익을 얻거나 비용을 줄이는 업무 규칙으로, 자동화된 시스템의 요소로 존재해야만 의미가 있다.

* 자동화된 시스템이 사용되는 방법을 설명.
* 애플리케이션에 특화된 업무 규칙을 설명.
* 사용자가 제공해야 하는 입력, 사용자에게 보여줄 출력, 해당 출력을 생성하기 위한 처리 단계를 기술.

## 엔티티를 제어

* 엔티티 내부의 핵심 업무 규칙을 어떻게, 언제 호출할지 명시하는 규칙을 담음.
* 엔티티가 어떻게 춤을 출지를 유스케이스가 제어.

## UI에 독립적

* 유스케이스만 봐서는 웹을 통해 전달되는지, 콘솔 기반인지 등을 구분 불가능.
    * 유스케이스는 시스템이 사용자에게 어떻게 보이는지를 설명하지 않음.
* 애플리케이션에 특화된 규칙을 설명하며, 사용자와 엔티티 사이의 상호작용을 규정.
* 시스템에서 데이터가 들어오고 나가는 방식은 유스케이스와 무관.

## 객체

* 유스케이스는 객체이며, 애플리케이션에 특화된 업무 규칙을 구현하는 하나 이상의 함수를 제공.
* 입력 데이터, 출력 데이터, 유스케이스가 상호작용하는 엔티티에 대한 참조 데이터 등의 데이터 요소를 포함.

## 의존성의 방향

* 유스케이스는 단일 애플리케이션에 특화되어 있고, 시스템의 입출력에 보다 가깝기 때문에 저수준.
* 엔티티는 수많은 다양한 애플리케이션에서 사용 가능하도록 일반화 되었고, 입력과 출력에 멀리 떨어져 있어서 고수준.
* 엔티티와 같은 고수준 개념은 유스케이스와 같은 저수준 개념에 대해 알지 못함.
    * 반대로 저수준의 유스케이스는 고수준인 엔티티에 대해 알고 있음.

</br>

# 요청 및 응답 모델

유스케이스는 단순한 요청 데이터 구조를 입력으로 받아들이고, 단순한 응답 데이터 구조를 출력으로 변환한다. 이 데이터 구조에는 어떤 것에도 (예를 들면, HttpRequest나 HttpResponse) 의존하지 않는다. 즉, 그 어떤 사용자 인터페이스에도 종속되는게 없어야 한다.

## 의존성 제거

요청 및 응답 모델이 독립적이지 않으면, 그 모델에 의존하는 유스케이스도 결국 해당 모델이 수반하는 의존성에 간접적으로 결합되어 버린다.

* 엔티티와 요청/응답 모델이 많은 데이터를 공유하여도 결합하고자 하는 유혹을 떨쳐내야 함.
* 시간이 지나면 두 객체는 완전히 다른 이유로 변경됨.
    * 공통 폐쇄 원칙, 단일 책임 원칙을 위반하는 결과를 불러일으킴.

<br/>

# 결론

업무 규칙은 소프트웨어 시스템이 존재하는 이유이고 핵심적인 기능이다. 

* 업무 규칙은 수익을 내고 비용을 줄이는 코드를 수반.
* UI나 DB 같은 저수준 관심사로부터 독립적.
* 업무 규칙을 표현하는 코드는 반드시 시스템의 심장부에 위치해야 함.
    * 덜 중요한 코드는 이 심장부에 플러그인되어야 함.
* 업무 규칙은 시스템에서 가장 독립적이며 가장 많이 재사용할 수 있는 코드여야 함.