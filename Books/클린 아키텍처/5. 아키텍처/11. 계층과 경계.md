
시스템이 보통 세 가지 컴포넌트(UI, 업무 규칙, DB)로만 구성된다고 생각하지만, 대다수의 시스템은 이보다 훨씬 많다.

# 움퍼스 사냥 게임

1972년에 발매된 인기있는 게임으로 텍스트를 기반으로 하는 게임이다.

* GO EAST, SHOOT WEST와 같은 매우 단순한 명령어를 사용.
* 플레이어는 명령어를 입력하며, 컴퓨터는 플레이어가 보고, 냄새 맡고, 듣고, 경험한 것들로 응답.

## 게임 시스템 변경

텍스트 기반 UI는 그대로 유지하지만, 게임 규칙과 UI를 분리해서 다양한 언어로 발매할 수 있게 만든다고 가정한다.

* 게임 규칙은 언어 독립적 API를 사용해서 UI 컴포넌트와 통신.
* UI는 API를 사람이 이해할 수 있는 언어로 변환.

<img src="./images/계층과 경계_1.jpeg" width="50%">

* 소스 코드 의존성을 적절히 관리하면, UI 컴포넌트가 어떤 언어를 사용하더라도 게임 규칙 재사용 가능.

마찬가지로 게임의 상태를 저장하는 저장소도 분리한다고 가정한다.

<img src="./images/계층과 경계_2.jpeg" width="50%">

* 게임 규칙이 저장소에 대한 세부사항을 알지 않도록 해야함.
* UI와 마찬가지로 API를 통해 게임 규칙이 데이터 저장소 컴포넌트와 통신할 때 사용하도록 만듦.
* 의존성 규칙을 준수할 수 있도록 의존성이 적절한 방향으로 향하도록 함.

<br/>

# 클린 아키텍처?

UI에서 언어 외에도 텍스트를 주고받는 메커니즘을 다양하게 만들고 싶을 수도 있다. 그래서 언어를 통신 메커니즘으로부터 격리하는 API를 생성해야 할 수도 있다.

<img src="./images/계층과 경계_3.jpeg" width="70%">

* 점선으로 된 테두리는 API를 정의하는 추상 컴포넌트를 가리킴.
    * 추상 컴포넌트 위나 아래의 컴포넌트가 구현.
* GameRules는 GameRules가 정의하고 Language가 구현하는 API를 이용해 Language와 통신.
* Language는 Language가 정의하고 TextDelivery가 구현하는 API를 이용해 TextDelivery와 통신.
* API는 구현하는 쪽이 아닌 사용하는 쪽에 정의되고 소속됨.

## 컴포넌트의 의존성 방향

English, SMS, CloudData와 같은 변형들을 모두 제거하고 API 컴포넌트만 집중하면 아래와 같은 구조로 단순화할 수 있다.

<img src="./images/계층과 경계_4.jpeg" width="50%">

* GameRules는 최상위 수준의 정책을 가지는 컴포넌트로 최상위에 놓임.

### 정보가 흐르는 방향

1. 모든 입력은 좌측 하단의 TextDelivery 컴포넌트로 전달.
2. Language를 거치면서 GameRules에 적합한 명령어로 번역.
3. GameRules는 사용자 입력을 처리.
4. 우측 하단의 DataStorage로 적절한 데이터를 내려 보냄.
5. GameRuls는 Language로 출력을 되돌려 보냄.
6. Language는 API를 다시 적절한 언어로 번역.
7. TextDelivery를 통해 사용자에게 전달.

데이터를 두 개의 흐름으로 효과적으로 분리한다. 

* 왼쪽은 사용자와의 통신에 관여. 
* 오른쪽은 데이터 영속성에 관여.

두 흐름은 상단의 GameRules에서 서로 만나며, GameRules는 두 흐름이 모두 거치게 되는 데이터에 대한 최종적인 처리기가 된다.

<br/>

# 흐름 횡단하기

데이터 흐름은 항상 두 가지일 수 없으며, 그 이상으로 분리될 수 있다. 움퍼스 사냥 게임을 네트워크상에서 여러 사람이 함께 플레이한다고 가정한다.

<img src="./images/계층과 경계_5.jpeg" width="70%">

* 네트워크 컴포넌트를 추가해야 함.
* 데이터 흐름을 세 개의 흐름으로 분리하며, 이들 흐름은 모두 GameRules가 제어.

시스템이 복잡해질수록 컴포넌트 구조는 더 많은 흐름으로 분리될 것이다.

<br/>

# 흐름 분리하기

이쯤 되면 모든 흐름이 결국엔 상단의 단일 컴포넌트에서 만난다고 생각할 수도 있으나, 현실은 이보다 훨씬 복잡하다.

## 정책의 분리

GameRules 컴포넌트의 일부는 지도와 관련된 메커니즘을 처리한다고 가정한다. 그리고 이보다 더 높은 수준에는 플레이어의 생명력, 특정 사건을 해결하는 비용과 얻게 될 소득 등을 알고 있는 정책이 있다.

<img src="./images/계층과 경계_6.jpeg" width="70%">

* 저수준 메커니즘과 관련된 정책에서는 고수준 정책에게 식량 발견이나 구덩이에 빠짐과 같은 사건이 발생했음을 알림.
* 고수준 정책에서는 플에이어의 상태와 게임 종료 후의 승리 여부 등을 관리.

### 마이크로서비스

더 들어가서 만약 대규모의 플레이어가 동시에 플레이할 수 있는 환경이라고 가정해보자.

<img src="./images/계층과 경계_7.jpeg" width="70%">

* MoveManagement는 플레이어의 컴퓨터에서 직접 처리되지만, PlayerManagement는 서버에서 처리.
* PlayerManagement는 접속된 모든 MoveManagement 컴포넌트에 마이크로서비스 API를 제공.
* MoveManagement와 PlayerManagement 사이에 완벽한 형태의 아키텍처 경계가 존재.

<br/>

# 결론

아키텍트로서 우리는 아키텍처 경계가 언제 필요한지를 신중하게 파악해야 한다.

* 경계를 제대로 구현하려면 비용이 많이 든다는 것을 인지해야 함.
* 경계가 무시되었다면 나중에 다시 추가하는 비용이 크다는 사실도 인지해야 함.
* 오버 엔지니어링이 언더 엔지니어링보다 나쁠 때가 훨씬 많을 수도 있다는것도 인지해야 함.
    * YAGNI 원칙.

계속 시스템이 발전함에 따라 주의를 기울이고 지켜봐야 한다.

* 경계가 필요할 수도 있는 부분에 주목.
* 경계가 존재하지 않아 생기는 마찰의 어렴풋한 첫 조짐을 신중하게 관찰.

그리고 판단해야 한다.

* 첫 조짐이 보이는 시점이 되면, 해당 경계를 구현하는 비용과 무시할 때 감수할 비용을 가늠.
* 결정된 사항을 자주 검토.

결국 우리의 목표는 경계의 구현 비용이 그걸 무시해서 생기는 비용보다 적어지는 바로 그 변곡점에 경계를 구현하는 것이다. 즉, 빈틈없이 계속 지켜봐야 한다.