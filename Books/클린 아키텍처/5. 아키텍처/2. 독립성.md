# 독립성

## 좋은 아키텍처

"1. 아키텍처"에서도 나왔지만 좋은 아키텍처는 특정 요소들을 지원해야 한다.

### 1. 유스케이스

아키텍처는 시스템의 의도를 드러내야 하는데, 만약 시스템이 장바구니 애플리케이션이라면 장바구니와 관련된 유스케이스를 지원해야 한다. 그러나 아키텍처는 시스템의 행위에 영향을 주지 않는다. 하지만 행위를 명확히 하고 외부로 드러내어 시스템이 지닌 의도를 아키텍처 수준에서 알 수 있게 해야한다.<br/>
그러기 위해 클래스와 함수 또는 모듈이 핵심적인 자리를 차지하고 있고, 자신의 기능을 분명하게 하는 이름을 가져야 한다. 그리고 이를 통해 유스케이스는 시스템 구조에서 한눈에 드러날 것이다.

### 2. 운영

만약 시스템이 초당 100,000명의 고객을 처리하거나, 수 밀리초 안에 3차원의 빅데이터 테이블에 질의해야 한다면, 이런 운영 작업을 허용할 수 있는 형태로 아키텍처를 구조화해야 한다.<br/>
그래서 시스템은 여러 형태의 구조(모노리틱, 마이크로서비스 등)로 구성되어지는데, 뛰어난 아키텍트라면 이런 시스템 형태의 결정사항을 열어두어야 한다. 만약 시스템이 모노리틱 구조라면 다중 프로세스, 다중 스레드 또는 마이크로서비스 형태가 필요해질 때 개선하기 어렵다.<br/>
그러나 컴포넌트를 적절히 격리하고 컴포넌트 간 통신 방식을 특정 형태로 제한하지 않는다면, 요구사항이 바뀌어도 시스템 형태를 전환하는 일이 훨씬 쉬워질 것이다.

### 3. 개발

아키텍처는 개발환경을 지원하는데 핵심적인 역할을 수행한다. 만약 여러 팀이 어떤 시스템을 개발한다면, 각 팀이 독립적으로 행동하기 편한 아키텍처를 확보하여 개발하는 동안 팀들이 서로를 방해하지 않도록 해야 한다. 그러기 위해서는 컴포넌트 단위로 시스템을 분할하여 독립적으로 작업할 수 있어야 한다.

### 4. 선택사항 열어놓기

좋은 아키텍처는 위 관심사 사이에서 균형을 맞추고 각 관심사 모두를 만족시킨다. 하지만 이러한 균형을 잡기가 힘든데 모든 유스케이스, 운영에 필요한 제약사항, 팀 구조, 배포 요구사항을 알지 못하며, 안다 하더라도 시간이 지날수록 이 사항들은 변해가기 때문이다.<br/>
그러나 그 중에서도 아키텍처 원칙은 변하지 않으며, 이 원칙들은 시스템을 컴포넌트 단위로 분할하는데 도움을 주고, 이를 통해 선택사항을 가능한 오랫동안 열어 둘 수 있게 해준다. 그럼으로써 향후 시스템의 변경에 쉽게 대응할 수 있게 된다.

## 결합 분리

아키텍트는 시스템의 기본적인 의도가 무엇인지 알고(장바구니 시스템인지 주문 처리 시스템인지) SRP와 CCP를 적용해서 다른 이유로 변경되는 것들은 분리하고, 동일한 이유로 변경되는 것들은 묶어야 한다.

### 1. 계층 결합 분리

서로 다른 이유로 변경되는 것들의 예로 UI와 업무 규칙, 데이터베이스가 있다. 이 요소들은 서로에게 아무런 관련이 없으며 각자 다른 속도, 다른 이유로 변경된다. 그리고 이렇게 함으로써 각 요소를 독립적으로 변경할 수 있으며, 이를 통해 시스템을 서로 결합되지 않은 수평적인 계층으로 분리할 수 있게 된다.

### 2. 유스케이스 결합 분리

다른 이유로 변경되는 것에는 유스케이스 그 자체가 있다. 주문 입력 시스템에서 주문을 추가하는 유스케이스와 주문을 삭제하는 유스케이스는 서로 다른 속도로, 다른 이유로 변경 된다. 그리고 유스케이스는 시스템의 수평적인 계층을 가로지르는 수직의 조각이기도 하다. 각 유스케이스는 UI의 일부, 업무 규칙의 일부, 데이터베이스 기능의 일부를 사용하기 때문이다.

<img src="./images/독립성_1.jpeg" width="70%">

## 결합 분리의 이점

### 1. 유스케이스 추가

시스템에서 서로 다른 이유로 변경되는 요소들의 결합을 분리하면 기존 요소에 지장을 주지 않고 새로운 유스케이스를 계속해서 추가할 수 있게 된다. 또한 유스케이스를 뒷받침하는 UI와 데이터베이스를 묶어서 각 유스케이스가 UI와 데이터베이스의 서로 다른 관점(aspect)을 사용하게 되면, 유스케이스 추가시 기존 유스케이스에 영향을 주는 일은 거의 없다.

### 2. 운영

유스케이스에서 서로 다른 관점이 분리되었다면, 높은 처리량을 보장해야 하는 유스케이스와 낮은 처리량으로도 충분한 유스케이스는 이미 분리되었을 가능성이 높다. 그리고 UI와 데이터베이스가 업무 규칙과 분리되어 있다면, UI와 데이터베이스는 업무 규칙과는 다른 서버에서 실행될 수 있다. 높은 대역폭을 요구하는 유스케이스는 여러 서버로 복제하여 실행할 수 있다.<br/>
따라서 결합 분리는 운영 측면에서도 도움이 되며, 결합을 분리할 때 적절한 모드(소스 수준, 배포 수준, 서비스 수준)를 선택해야 한다.

### 3. 개발 독립성

컴포넌트가 완전히 분리되면 팀 사이의 간섭은 줄어든다. UI에 중점을 둔 팀과 업무 규칙에 중점을 둔 팀은 서로 영향을 줄 수 없고, 유스케이스 자체에서도 addOrder에 중점을 둔 팀과 deleteOrder에 중점을 둔 팀은 서로 영향을 줄 수 없다.<br/>
어떤 형태의 팀이라도 계층과 유스케이스의 결합이 분리되는 한 시스템의 아키텍처는 그 팀 구조를 뒷받침해 줄 것이다.

### 4. 배포 독립성

결합을 제대로 분리했다면 운영 중인 시스템에서도 계층과 유스케이스를 교체할 수 있다. 유스케이스를 추가하는 것은 새로운 jar 파일이나 서비스를 추가하는 정도로 단순한 일이 된다.

## 결합 분리 모드

계층과 유스케이스의 결합을 분리하는 방법은 다양하다.

### 1. 소스 수준 분리 모드

소스 코드 모듈 사이의 의존성을 제어할 수 있으며, 하나의 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일하지 않도록 만들 수 있다(예, 루비 Gem). 보통 모든 컴포넌트가 같은 주소 공간에 있고, 통신에 함수 호출을 사용하는 모노리틱 구조로 구성된다.

### 2. 배포 수준 분리 모드

jar 파일, DLL, 공유 라이브러리와 같이 배포 가능한 단위들 사이의 의존성을 제어할 수 있다. 이를 통해 각 모듈의 소스 코드가 변하더라도 다른 모듈을 재빌드 하거나 재배포하지 않도록 할 수 있다.<br/>
컴포넌트들은 같은 주소 공간에 상주하며 함수 호출을 통해 통신할 수도 있고, 동일한 프로세서의 다른 프로세스에 상주하면서 프로세스 간 통신, 소켓, 공유 메모리를 통해 통신할 수도 있다. 이 모드의 중요한 특징은 결합이 분리된 컴포넌트가 독립적으로 배포할 수 있는 단위로 분할되어 있다는 것이다.

### 3. 서비스 수준 분리 모드

의존 수준을 데이터 구조 단위까지 낮추고, 네트워크 패킷을 통해서만 통신하도록 만들 수 있다. 모든 실행 가능한 단위는 서스와 바이너리 변경에 대해 서로 완전히 독립적이게 된다. (예, 마이크로서비스)

### 어떤 모드가 좋은가?

프로젝트 초기에는 알 수 없으며 프로젝트가 성숙해갈수록 최적인 모드가 달라진다. 개발, 배포, 운영적인 문제가 증가하면 서비스 수준으로 전환할 배포 단위들을 신중하게 선택한 후, 점차 이 방향으로 시스템을 변경해 나간다. 그래서 컴포넌트가 서비스화될 가능성이 있다면 컴포넌트 결합을 분리하되 서비스가 되기 직전에 멈추어 서비스에 대한 선택권을 열어두는 것이 좋다.<br/>
또한 시간이 흘러 운영 요구사항이 감소되면 서비스 수준으로 분리했던 것을 배포나 소스 수준의 결합 분리만으로 충분할 수도 있다. 이처럼 좋은 아키텍처는 이러한 변경들로부터 소스 코드 대부분을 보호하고 결합 분리 모드를 선택사항으로 남겨두어서 배포 규모에 따라 가장 적합한 모드를 선택해 사용할 수 있게 만들어 준다.

## 중복 제거 유의

보통 일반적으로 일반적으로 제거해야하는 안 좋은 것이지만 이 중복이 거짓된 우발적인 중복인지를 꼭 확인하고 제거해야 한다.<br/>
예를 들어 유스케이스를 분리할 때 유스케이스가 서로 비슷한 화면 구조, 비슷한 알고리즘, 비슷한 데이터베이스 쿼리와 스키마를 가진다고 자동반사적으로 중복을 제거해서 코드를 통합시켜버리면 안 된다. 나중에는 각자 다른 모습으로 분기할 가능성이 크기 때문이다.<br/>
마찬가지로 수평 분리의 관점에서도 데이터베이스 레코드와 특정 화면의 데이터 구조가 비슷하다고해서 데이터베이스 레코드를 그대로 UI까지 전달하면 안 된다.<br/>

## 결론

결합을 분리하는 것은 어렵고 까다로우며 결합 분리 모드를 변경하기가 쉬운 것도 아니다. 하지만 시스템의 결합 분리 모드는 시간이 지나면서 바뀌기 쉬우며, 아키텍트라면 이런 변경을 예측하고 큰 무리 없이 반영할 수 있도록 만들어야 한다.





