SOA와 MSA는 최근에 많이 사용되는 아키텍처이다. 그 이유는,

* 서비스를 사용하면 상호 결합이 철저하게 분리되는 것처럼 보임.
* 서비스를 사용하면 개발과 배포 독립성을 지원하는 것처럼 보임.

이 이유들은 일부분에 대해서만 맞다.

# 서비스 아키텍처?

서비스를 사용한다는 것이 본질적으로 아키텍처에 해당하지는 않는다.

* 아키텍처는 의존성 규칙을 준수하고, 고수준의 정책을 저수준 세부사항으로부터 분리하는 경계에 의해 정의됨.
* 단순히 애플리케이션의 행위를 분리하는 서비스라면 값비싼 함수 호출에 불과.

기능을 프로세스나 플랫폼에 독립적이게끔 서비스들을 생성하면 의존성 규칙 준수 여부와 상관없이 큰 도움이 될 때가 많지만 서비스 그 자체로 아키텍처를 정의하지는 않는다.

* 결국 서비스는 프로세스나 플랫폼 경계를 가로지르는 함수 호출에 지나지 않음.
* 물론 아키텍처적으로 중요한 서비스도 존재.

<br/>

# 서비스의 이점?

서비스 아키텍처를 통해 얻는 이점에는 불완전한 부분이 존재한다.

## 1. 결합 분리의 오류

시스템을 서비스들로 분리함으로써 서비스 사이의 결합이 확실히 분리될 것이라 기대한다.

* 각 서비스는 서로 다른 프로세스, 심지어 서로 다른 프로세서에서 실행.
    * 따라서 다른 서비스의 변수에 접근 불가.
* 모든 서비스의 인터페이스는 잘 정의되어야 함.

### 공유 자원에 의한 결합

서비스는 개별 변수 수준에서 각각 결합이 분리되지만, 프로세서 내의 또는 네트워크 상의 공유 자원 때문에 결합될 가능성이 여전히 존재한다.

예를 들어, 서비스 사이를 오가는 데이터 레코드에 새로운 필드 추가 시,

* 이 필드를 사용해 동작하는 모든 서비스에 변경 필요.
* 이 필드에 담긴 데이터를 해석하는 방식을 사전에 조율.

따라서 서비스들 사이는 서로 간접적으로 결합되어 버린다.

### 서비스 인터페이스 정의

인터페이스가 잘 정의되어야 한다는 이점에 대해서는 명백한 사실이다. 

* 하지만 함수의 경우와 크게 차이 없음.
* 서비스 인터페이스가 함수 인터페이스보다 더 엄밀하거나, 더 엄격하고, 더 잘 정의되는 것이 아님.

## 2. 개발 및 배포 독립성의 오류

또 하나의 예측되는 이점으로, 각 전담팀이 서비스를 소유하고 운영한다는 점이다. 

* 대규모 엔터프라이즈 시스템을 독립적으로 개발하고 배포 가능한 수십 ~ 수천 개의 서비스들을 이용하여 만들 수 있다고 믿음.
* 시스템의 개발, 유지보수, 운영 또한 비슷한 수의 독립적인 팀 단위로 분할 가능하다고 생각.

그러나 일부분에 대해서만 맞는 말이다.

### 대규모 엔터프라이즈의 유일한 대안?

모노리틱 시스템이나 컴포넌트 시스템으로도 대규모 엔터프라이즈 시스템 구축이 가능하다. 따라서, 서비스는 확장 가능한 시스템을 구축하는 유일한 선택지가 아니다.

### 결합 분리 오류

결합 분리의 오류에 의해, 데이터나 행위에서 어느 정도 결합된다면 그에 맞게 개발, 배포, 운영을 조정해야만 한다.

<br/>

# 두 가지 오류에 대한 예시

## 택시 통합 시스템

택시 업체들과 승객을 연결시켜주는 택시 통합 시스템이 있다. 승객은 승차 시간, 비용, 고급 택시 여부, 운전사 경력 등 여러 기준으로 택시를 선택할 수 있다.

아래는 마이크로 서비스로 이루어진 해당 시스템에 대한 서비스 다이어그램이다.

<img src="./images/크고 작은 모든 서비스들_1.jpeg">

* TaxiUI : 고객을 담당. (모바일 UI)
* TaxiFinder : 여러 TaxiSupplier의 현황을 검토, 적합한 택시 후보들을 선별.
* TaxiSelector : 사용자가 지정한 조건을 기초로 후보 택시 중에서 적합한 택시 선택.
* TaxiDispatcher : 선택된 택시를 전달받아 해당 택시에 배차를 지시.

### 야옹이 문제

갑자기 택시 통합 시스템에 야옹이를 배달하는 서비스 제공이 결정되었다. 사용자는 자신의 집이나 사무실로 야옹이를 배달해달라고 주문할 수 있다.

* 먼저 도시 전역에 야옹이를 태울 다수의 승차 지점 설정.
* 야옹이 배달 주문시, 근처의 택시가 선택.
* 승차 지점 중 한 곳에서 야옹이를 태운 후, 야옹이 배달.
* 고양이 알러지가 있는 승객에게는 3일 사이에 야옹이 배달 서비스를 했던 택시를 배차하지 말아야 함.

이제 야옹이 배달 기능을 추가하려면 모든 서비스에 변경이 필요하다. 즉, 서비스들은 모두 결합되어 있어서 독립적으로 개발, 배포, 유지될 수 없다.

## 해결 : 컴포넌트 기반 아키텍처

SOLID 설계 원칙에 따라 다형적으로 확장할 수 있는 클래스 집합을 생성해 새로운 기능을 처리하도록 한다.

<img src="./images/크고 작은 모든 서비스들_2.jpeg">

* 배차에 특화된 로직 부분은 Rides 컴포넌트로 추출.
* 야옹이에 대한 신규 기능은 Kittens 컴포넌트로 이동.
* 기존 컴포넌트들에 있는 추상 기반 클래스를 템플릿 메서드나 전략 패턴 등으로 오버라이드.

Rides와 Kittens 컴포넌트는 의존성 규칙을 준수하고 있다. 그리고 UI의 제어하에 팩토리가 생성한다.

* 야옹이 기능 구현시 TaxiUI도 어쩔 수 없이 변경 필요.
* 하지만 이 외의 것은 변경할 필요 없음.

이제 야옹이 기능을 구현한 새로운 jar, Gem 등의 파일을 시스템에 추가하고, 런타임에 동적으로 로드하면 된다. 따라서, 야옹이 기능은 결합이 분리되고 독립적으로 개발, 배포가 가능하다.

## 해결 : 컴포넌트 기반 서비스

서비스 또한 SOLID 원칙대로 설계 가능하며, 컴포넌트 구조를 갖출 수도 있다.

* 자바의 경우, 서비스를 하나 이상의 jar 파일에 포함되는 추상 클래스들의 집합으로 생각.
    * 새로운 기능 추가/확장은 새로운 jar 파일로 만듦.
    * 새로운 jar 파일을 구성하는 클래스들은 기존 jar 파일에 정의된 추상 클래스들을 확장해서 만듦.
* 새로운 기능 배포는 서비스 재배포가 아닌, 단순히 jar 파일을 추가하는 문제가 됨.

<img src="./images/크고 작은 모든 서비스들_3.jpeg">

각 서비스의 내부는 자신만의 컴포넌트 설계로 되어 있어서, 파생 클래스를 만드는 방식으로 신규 기능을 추가한다. 파생 클래스들은 각자의 컴포넌트 내부에 위치한다.

## 횡단 관심사

위 예시들을 보면서 아키텍처 경계가 서비스 사이에 있지 않음을 알 수 있다.

* 아키텍처 경계는 서비스를 관통하며, 서비스를 컴포넌트 단위로 분할.

<img src="./images/크고 작은 모든 서비스들_4.jpeg" width="50%">

그리고 모든 시스템은 야옹이 문제와 같은 횡단 관심사 문제를 직면하게 된다. 그래서 위 다이어그램처럼,

* 서비스 내부는 의존성 규칙도 준수하는 컴포넌트 아키텍처로 설계해야 함.
* 서비스들은 시스템의 아키텍처 경계를 정의하지 않음.

따라서 아키텍처 경계를 정의하는 것은 서비스 내에 위치한 컴포넌트이다.

<br/>

# 결론

서비스는 시스템의 확장성과 개발 가능성 측면에서 유용하지만, 아키텍처적으로 그리 중요한 요소가 아니다.

* 아키텍처는 시스템 내부에 그어진 경계와 경계를 넘나드는 의존성에 의해 정의됨.