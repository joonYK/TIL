시스템 아키텍처는 일련의 소프트웨어 컴포넌트와 그 컴포넌트들을 분리하는 경계에 의해 정의된다.

# 경계 횡단하기

런타임에 경계를 횡단하는 것은 경계 한쪽에 있는 기능에서 반대편 기능을 호출하여 데이터를 전달하는 것이다.

## 경계 횡단을 위한 소스 코드 의존성 관리

* 적절한 위치에서 경계를 횡단하기 위함.
    * 소스 코드 모듈 하나가 변경되면, 의존하는 다른 모듈도 변경하거나, 재 컴파일 및 배포가 필요할 수 있음.
* 결국 경계는 변경이 전파되는 것을 막는 방화벽을 구축하고 관리하는 수단.

<br/>

# 경계의 형태

## 1. 단일체

물리적으로 엄격하게 구분되지 않은 형태로, 함수와 데이터가 단일 프로세서에서 같은 주소 공간 공유한다. (소스 수준 분리 모드)

### 배포 관점

* 단일 실행 파일로 jar나 .EXE 파일 등.
* 배포 관점에서 볼 때 단일체는 경계가 드러나지 않음.

### 동적 다형성

* 이런 아키텍처는 거의 모든 경우 동적 다형성에 의존하여 내부 의존성을 관리.
* 객체 지향의 중요성이 부각되었으며, 이 패러다임이 아니었다면 포인터라는 위험한 옛 관행에 기대었을 것임.

#### ※ 정적 다형성

* 모노리틱 시스템에서는 정적 다형성(제네릭, 템플릿 등)을 사용해서 의존성을 관리하는 편.
* 특히 C++와 같은 언어에서 사용.
* 동적 다형성의 경우 재컴파일이나 재배포가 필요한 경우를 대체로 방지 가능하나, 제네릭이 제공하는 결합 분리 방식은 동적 다형성이 제공하는 수준에 미치지 못함.

### 경계 횡단

#### 저수준 클라이언트 -> 고수준 서비스

* 가장 단순한 형태로 저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출.
* 런타임 의존성과 컴파일타임 의존성 모두 저수준 컴포넌트에서 고수준 컴포넌트로 향함.

<img src="./images/경계 해부학_1.jpeg">

* 그림에서 제어흐름은 왼쪽에서 오른쪽으로 경계를 횡단.
* Data는 경계에서 호출되는 쪽에 정의되어 위치함.

#### 고수준 클라이언트 -> 저수준 서비스

* 동적 다형성을 사용하여 제어흐름과 반대 방향으로 의존성을 역전.
* 런타임 의존성은 컴파일타임 의존성과 반대가 됨.

<img src="./images/경계 해부학_2.jpeg">

* 그임에서 제어흐름은 왼쪽에서 호른쪽으로 횡단.
* 그러나 횡단시에 의존성은 모두 오른쪽에서 왼쪽으로 고수준 컴포넌트를 향함.
* 데이터 구조의 정의 또한 호출하는 쪽(고수준)에 위치함.

### 개발 및 배포

* 정적 링크된 모노리틱 구조의 실행 파일이라도 규칙적인 방식으로 구조를 분리가 필요.
* 팀들이 서로의 영역에 침범하지 않으며 자신만의 컴포넌트를 독립적으로 작업 가능.
* 고수준 컴포넌트는 저수준 세부사항으로부터 독립적으로 유지.
* 단일체를 배포하는 일은 일반적으로 컴파일과 정적 링크 작업을 수반하므로, 이러한 시스템에서 컴포넌트는 소스 코드 형태로 전달.

## 2. 배포형 컴포넌트

아키텍처의 경계가 물리적으로 드러나는 형태로 예를 들어, .NET DLL, 자바 jar 파일, 루비 Gem, 유닉스 공유 라이브러리 등이 있다. 바이너리와 같이 배포 가능한 형태로 전달되어 컴파일하지 않고 바로 사용 가능. (배포 수준 결합 분리 모드)

### 단일체와 비슷한 사용 전략

* 배포 과정에서만 차이가 날 뿐, 단일체와 동일.
* 모든 함수가 동일한 프로세서와 주소 공간에 위치.
* 컴포넌트를 분리하거나 컴포넌트 간 의존성을 관리하는 전략도 단일체와 동일.
    * 정적 다형성은 사용할 수 없음.
* 단일체처럼 경계를 가로지르는 통신은 순전히 함수 호출에 지나지 않음.

## 3. 로컬 프로세스

훨씬 강한 물리적 형태를 띠는 아키텍처 경계이며, 주로 명령행이나 그와 유사한 시스템 호출을 통해 생성한다.

### 실행

* 로컬 프로세스들은 동일한 프로세서 또는 하나의 멀티코어 시스템에 속한 여러 프로세서들에 의해 실행.
    * 각각이 독립된 주소 공간에서 실행.
* 일반적으로 메모리 보호를 통해 프로세스들이 메모리를 공유하지 못함.
    * 종종 공유 메모리 파티션을 사용.
    * 소켓이나 메일박스, 메시지 큐와 같이 OS에서 제공하는 통신 기능을 이용하여 통신.

### 구성

#### 1. 정적으로 링크된 단일체로 구성.

* 여러 모노리틱 프로세스가 같은 컴포넌트들을 가지고 있을 수 있음.
* 컴파일하고 정적 링크하는 과정에서 각 컴포넌트의 바이너리가 단일체에 물리적으로 복사되기 떄문.

#### 2. 동적으로 링크된 여러개의 컴포넌트로 구성.

* 동적으로 링크된 배포형 컴포넌트들을 서로 공유.

### 단일체나 배포형 컴포넌트와 비슷한 사용 전략

* 로컬 프로세스를 일종의 최상위 컴포넌트로 생각.
    * 로컬 프로세스는 컴포넌트 간 의존성을 동적 다형성을 통해 관리하는 저수준 컴포넌트로 구성.
* 고수준 프로세스의 소스 코드가 저수준 프로세스의 이름, 물리 주소, 레지스트리 조회 키를 포함하지 않음.
* 저수준 프로세스가 고수준 프로세스의 플러그인이 되도록 만듦.
* 경계 횡단은 OS 호출, 데이터 마샬링 및 언마샬링, 프로세스 간 문맥 교환 등으로 통신.

## 4. 서비스

물리적인 형태를 띠는 가장 강력한 경계이며, 명령행 또는 그와 동등한 시스템 호출을 통해 구동되고, 물리적 위치에 구애받지 않는다.

### 구조

* 서로 통신하는 두 서비스는 물리적으로 동일한 프로세서나 멀티코어에서 동작 가능.
* 서비스들은 모두 통신이 네트워크를 통해 이뤄진다고 가정.

### 경계 횡단

* 함수 호출 방식에 비해 매우 느려서, 주의를 기울여 빈번하게 통신하는 일을 방지.
* 통신 지연에 따른 문제를 고수준에서 처리할 수 있어야 함.

### 로컬 프로세스와 비슷한 사용 전략

* 저수준 서비스는 반드시 고수준 서비스에 플러그인이 되어야 함.
* 고수준 서비스의 소스 코드에는 저수준 서비스를 특정 짓는 어떤 정보(URL 등)도 포함하면 안 됨.

<br/>

# 결론

단일체를 제외한 대다수의 시스템은 한 가지 이상의 경계 전략을 사용한다.

* 서비스 전략은 로컬 프로세스 경계도 일부 포함하고 있을 수 있음.
    * 상호작용하는 일련의 로컬 프로세스 퍼사드에 불과할 떄가 많음.
* 서비스나 로컬 프로세스는 소스 코드 컴포넌트로 구성된 단일체이거나 동적으로 링크된 배포형 컴포넌트의 집합으로 구성.
