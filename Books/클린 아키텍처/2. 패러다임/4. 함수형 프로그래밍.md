# 함수형 프로그래밍

이 패러다임은 프로그래밍 그 자체보다 앞서 등장했고, 핵심 기반은 람다 계산법으로 알론조 처치가 1930년대에 발명했다. 함수형 프로그래밍은 변수의 가변성을 제거해서 동시성 애플리케이션의 문제들을 해결할 수 있다. 그래서 변수 할당에 부과되는 규율이 존재한다.

## 정수 제곱

* 25까지의 정수의 제곱을 출력하는 간단한 문제를 자바와 함수형 언어인 클로저로 작성.

### 자바

```java
public class Squint {
    public static void main(String args[]) {
        for (int i = 0; i < 25; i++)
            System.out.println(i*i);
    }
}
```

* 자바는 가변 변수를 사용, 프로그램 실행 중에 상태가 변할 수 있음.
* 위에서 반복문을 제어하는 변수인 i가 가변 변수로 0부터 25까지 계속 변함.

### 클로저

```Clojure
(println (take 25 (map (fn [x] (* x x)) (range))))

;; 1. range 함수는 0부터 시작해서 정수를 반환.
;; 2. range의 정수가 map 함수로 전달되고 제곱 계산하는 익명 함수가 실행되어 반환.
;; 3. 제곱 계산된 정수 리스트가 take로 전달되어 25개까지만 리스트 구성해서 반환.
;; 4. println 함수에서 출력.
```

* 클로저는 가변 변수가 존재하지 않음.
* 익명 함수의 x와 같은 변수가 한 번 초기화되면 절대로 변하지 않음.

## 불변성과 아키텍트

아키텍처를 고려할 때 아키텍트는 변수의 가변성을 고려해야 한다. 경합 조건, 교착상태, 동시 업데이트 문제가 모두 가변 변수로 인해 발생하기 때문이다. 즉, 다수의 스레드와 프로세스를 사용하는 애플리케이션에서 마주치는 모든 문제는 가변 변수가 없다면 절대로 생기지 않는다.

## 가변성의 분리

애플리케이션을 제대로 구조화하려면 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야 한다. 불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되고, 어떤 가변 변수로 사용되지 않으며, 하나 이상의 다른 가변 컴포넌트와 서로 통신한다.<br/>
그리고 이렇게 분리하려면 동시 업데이트와 경합 조건 문제로부터 가변 변수들을 보호하기 위해 트랜잭션 메모리와 같은 적절한 수단을 동원해야 한다.<br/>
결론적으로 현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야 한다.

## 이벤트 소싱

이벤트 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략으로, 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.<br/>
예로, 고객의 계좌 잔고를 관리하는 은행 애플리케이션에이 있을 때, 입금과 출금 트랜잭션이 실행되면 잔고를 변경하지 않고, 잔고 조회시에 계좌 개설 시점부터 발생한 모든 트랜잭션을 단순히 더하는 개념이다. 이 전략에는 가변 변수가 하나도 필요 없다.<br/>
데이터 저장소에서는 변경과 삭제가 전혀 발생하지 않으므로 동시 업데이트 문제 또한 일어나지 않는다.