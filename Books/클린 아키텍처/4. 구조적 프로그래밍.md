# 구조적 프로그래밍

제대로 된 프로그래밍 패러다임 정립되지 않아 프로그래밍에 어려움이 있을 때에 데이크스트라가 수학적 증명 방식을 토대로 프로그래밍을 기법을 발전시키는 과정에서 탄생하게 된 패러다임이다.<br/>
무분별하게 남발하던 goto를 제한하도록 유도하고, 모듈의 분해와 조립을 통한 개발, 각 모듈은 제어 구조(순차, 분기, 반복)만으로 이루어질 수 있는 등 구조적 프로그래밍의 뼈대를 세웠다. 

## 증명

데이크스크라는 프로그래밍의 어려움을 수학자가 사용하는 유클리드 계층구조 방식을 사용해서 해결하려 했다.<br/>
입증된 구조를 이용하고, 이 구조들을 코드와 결합해서 코드가 올바르다는 사실을 스스로 증명하게 되는 방식인데, 그에 따라 증명을 작성할 수 있는 기법이 필요했으며, 모듈을 분해해 분할 정복 접근법으로 증명을 하고자 했다.

#### ※ 유클리드 계층구조

* 증명이라는 수학적인 원리를 도입하기위해 공리, 정리, 따름정리, 보조정리로 구성되는 유클리드 계층구조를 만들고자 함.
* 공리(axiom) : 증명 없이 참으로 받아들이는 명제.
* 정리(theorem) : 증명이라는 과정을 통해 참이라는 것이 밝혀진 명제.
* 보조정리(lemma) : 정리를 증명하는 데 필요한 정리.
* 따름정리(corollary) : 정리를 통해 자연스럽게 도출되는 정리.

### goto

1968년에 데이크스트라는 CACM 편집자에게 'goto문의 해로움'이라는 제목의 편지를 보냈고 이 내용에 대한 지지하는 자와 반대하는 자들의 전쟁이 10년이상 지속되었으며, 결국 goto문은 거의 사라지게 되었다.
goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 될 수 있음을 발견했다.<br/>
그리고 문제가 되지 않았던 goto문의 사용 방식은 오늘날의 분기와 반복 제어 구조에 해당함을 발견했다.<br/>

### 제어 구조

제어 구조는 순차 실행과 결합했을 때 특별하다는 사실을 발견했는데, 이미 2년 앞서서 뵘과 야코피니가 모든 프로그램을 순차, 분기, 반복 세 가지 구조로 표현가능하다는 사실을 증명했다.<br/>
즉, 모듈을 증명하는 그 제어 구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일하단 사실이었고 이것은 구조적 프로그래밍의 탄생을 의미했다.

## 기능적 분해

구조적 프로그래밍을 통해 고수준의 기능들과 그 기능들의 저수준 함수들로 분해하는 과정을 끝없이 반복할 수 있게 되었다. 그리고 이렇게 분해된 기능들은 구조적 프로그래밍의 제한된 제어 구조를 이용하여 표현할 수 있다.<br/>
이를 토대로 구조적 분석이나 구조적 설계 같은 기법이 인기를 끌었다. 이 기법으로 대규모 시스템을 모듈과 컴포넌트로 나누고, 모듈과 컴포넌트를 입증할 수 있는 아주 작은 기능들로 세분화할 수 있게 되었다.

## 엄밀한 증명은 없었다

프로그램 관점에서 정리에 대한 유클리드 계층구조는 끝내 만들어지지 않았다. 세세한 기능 하나하나를 증명하는 작업은 힘들었고, 오늘날 엄밀한 증명이 고품질의 소프트웨어를 생산하기 위한 적절한 방법이라 믿는 프로그래머는 이제 거의 없다.

## 과학이 구출하다

과학은 과학 이론과 법칙은 그 올바름을 절대 증명할 수 없어서 수학과 근본적으로 다르다. 즉, 과학적 방법은 반증은 가능하지만 증명은 불가능하다.<br/>
과학은 서술된 내용이 틀렸음을 증명하는 방식으로 동작하기 때문에 반례를 들 수 없는 서술이 있다면 목표에 부합할 만큼은 참이라고 본다.<br/>
결론적으로 수학은 증명 가능한 서술이 참임을 입증하는 원리라 볼 수 있고, 과학은 증명 가능한 서술이 거짓임을 입증하는 원리라 할 수 있다.

## 테스트

테스트는 프로그램이 잘못되었음을 증명할 수는 있지만, 맞다고 증명할 수는 없다. 테스트가 보장할 수 있는 것은 프로그램이 목표에 부합할 만큼은 충분히 참이라고 여길 수 있게 해주는 것이 전부다. 그래서 소프트웨어는 수학보다 오히려 과학과 같다.<br/>
구조적 프로그래밍은 증명 가능한 세부 기능 집합으로 재귀적으로 분해하고 테스트를 통해 증명 가능한 세부 기능들이 거짓인지를 증명하려고 시도한다. 테스트가 실패한다면 이 기능들은 목표에 부합할 만큼은 충분히 참이라고 여기게 된다.

## 결론

구조적 프로그래밍이 오늘날까지 가치 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 능력 때문이다. 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들기 위해 분주히 노력해야 한다.
