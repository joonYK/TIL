# JVM 구조

<img src="./images/jvm.png" width="90%">

## 클래스 로더

* .class 파일의 바이트 코드를 읽어들여서 메모리에 적절하게 배치하는 역할을 담당.
* 로딩 -> 링크 -> 초기화 순으로 진행.

### Loading : 클래스를 읽어오는 과정

* 클래스 파일을 읽고 그 내용에 따라 바이너리 데이터를 만들어 메소드 영역에 저장.
    * 메소드 영역에 저장하는 데이터
        * 풀 패키지 이름을 포함한 클래스 이름 (FQCN, Fully Qualified Class Name)
        * 클래스, 인터페이스, 이늄 여부
        * 메소드와 변수
* 로딩이 끝나면 해당 클래스 타입의 Class 객체가 Heap 영역에 저장됨.
    * MyClass라는 클래스를 정의하면 소스상에서 MyClass.class로 class 객체(Class&lt;MyClass&gt;)에 접근할 수 있음.
* 각 단계별 로더
    1. Bootstrap Class Loader : jre의 lib폴더에 있는 rt.jar 파일을 찾아 자바 기본 클래스들을 로드.
    2. Platform(구 Extension) Class Loader : jre의 lib폴더에 있는 ext 폴더에 위치한 확장 코어 클래스 파일들을 로드.
    3. Application Class Loader : 사용자가 직접 정의한 클래스 파일들을 로드. Classpath 환경변수에 있는 클래스 파일이나 -classpath 또는 -cp 명령어 옵션이 있는 파일들을 로드.


### Linking(연결)

* 로드된 클래스 파일들을 검증하고 사용할 수 있게 준비하는 단계.
* Verify(검증), Prepare(준비), Resolve(optional) 세 단계로 나뉨.
* 검증 단계 : .class 파일 형식이 유효한지 체크. 임의로 class 파일을 조작하면 에러 발생.
* 준비 단계 : 클래스 변수(static 변수)와 기본값에 필요한 메모리 준비.
* 해결 단계 : 심볼릭 메모리 레퍼런스를 메소드 영역에 있는 실제 레퍼런스로 교체. (optional이므로 Linking에서 이 작업이 실행되거나 실제 레퍼런스를 사용할 때 실행됨)

#### 심볼릭 메모리 레퍼런스 (명확하게 정의되지 않은 레퍼런스)

```java
MyClass myClass = new MyClass();
```

* 위의 코드를 읽었다 하더라도 myClass는 실제 heap 영역의 레퍼런스를 가리키고 있지 않음.
* 힙 영역의 실제 레퍼런스를 가리키도록 하는 작업을 Linking 과정의 Resolve 단계에서 발생하거나(optional) 실제 사용될 때 발생.

### 초기화

* static 변수의 값 할당.
* static 블럭이 있다면 이때 실행됨.

<br/>

## 메모리

* 전체 쓰레드가 공유하는 영역 : 메소드, 힙.
* 쓰레드별 영역 : 스택, PC 레지스터, 네이티브 메소드 스택.

### 메소드 영억

* 클래스 수준의 정보들을 저장.
* 클래스 이름(풀패키지 정보), 부모 클래스 이름, 메소드, 변수.
* 공유 자원. 다른 영역에서 참조 가능.

### 힙

* 인스턴스들을 저장.
* 공유 자원.

### 스택

* 쓰레드마다 런타임 스택을 만드는데, 그 안에 스택 프레임(메서드 콜)이라 부르는 블럭을 쌓음.
    * 스택 프레임에는 로컬 변수, 일부 실행 결과, 메소드 호출이나 반환 등을 저장.
    * Frame을 push하거나 pop하는 동작만 수행.
    * 스택 프레임의 예로, 에러 메시지를 볼 때 메서드가 쌓여있는걸 볼 수 있음.
* 쓰레드 종료시 런타임 스택도 사라짐.

### PC(Program Counter) 레지스터

* 쓰레드마다 생성되며 쓰레드 내에 실행할 스택 프레임을 가리키는 포인터 생성.

### 네이티브 메소드 스택

* 네이티브 메소드 인터페이스를 위한 메모리 공간.
* 네이티브 메소드 라이브러리(구현체)는 JNI(인터페스)를 통해서 사용이 되는데, JNI를 위한 스택 메모리 공간이다.
    * 네이티브 메소드 스택에 JNI 메서드를 콜한 스택 프레임이 쌓이게 됨.
* 네이티브 메소드가 실행될떄는 바이트 코드의 명령어가 없기 때문에 PC 레지스터는 비어있음.

#### 네이티브 메소드

* 메소드에 native라는 키워드가 붙어있고 그 구현을 자바가 아닌 C나 C++로 한 것.
* java core 라이브러리들은 대부분 다 네이티브 메소드. ex) Thread.currentThread();

<br/>

## 실행 엔진

### 인터프리터

* 바이트 코드를 한 줄씩 실행.
* 바이트 코드를 기계가 이해할 수 있는 네이티브 코드(기계어)로 번역.

### JIT 컴파일러

* 인터프리터 사용시 똑같은 코드가 여러번 실행되어도 매번 컴파일하는 것은 비효율적.
* 인터프리터 효율을 높이기 위해서 반복되는 코드를 발견하면 JIT 컴파일러로 반복되는 코드를 모두 네이티브 코드로 컴파일.
    * 이후부터 인터프리터는 컴파일하지 않고 네이티브로 컴파일된 코드를 사용.

### GC

* 더이상 참조회지 않는 객체를 모아서 정리.
* 경우에 따라 옵션을 조정하거나 애플리케이션에 따라 사용하는 GC를 선택해야하는 경우도 있음.
* GC를 크게 둘로 나누면 throughtput GC와 stop-the-world를 줄이는 GC가 있음. [자료](https://linux.systemv.pe.kr/%EC%9C%A0%EC%9A%A9%ED%95%9C-jvm-%ED%94%8C%EB%9E%98%EA%B7%B8%EB%93%A4-part-6-throughput-collector/#Throughput_vs_pause_times)