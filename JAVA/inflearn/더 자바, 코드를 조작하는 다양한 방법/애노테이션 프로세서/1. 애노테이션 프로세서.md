# 애노테이션 프로세서

## 동작

* 컴파일 단계에서 Annotation에 정의된 프로세스를 동작.
    * 빌드 단계에서 에러 출력 가능.
    * 소스코드나 바이트코드 또는 파일을 생성.
    * 소스코드 변경도 가능하나 공식 api를 통해서는 불가능하기 떄문에 권장하지 않음.
* 여러 라운드에 거쳐 실햄됨.
    * 각 라운드마다 컴파일러가 소스코드에서 애노테이션을 검색하고 해당 애노테이션 프로세서를 선택하는것으로 시작.
    * 프로세스중에 파일이 생성되면 해당 소스파일을 입력으로 해서 새로운 라운드가 시작되고 파일이 생성되지 않을때까지 반복.

## 예제

* 롬복 라이브러리
* @Override
    * 부모 클래스의 메서드를 재정의하거나 인터페이스의 메서드 구현할 때, 메서드 형식이 다르면 컴파일 단계에서 에러 발생.

## 장점

* 컴파일 단계에서 조작하기 때문에 런타임시에 추가적인 비용이 들지 않음.
    * java agent나 다른 라이브러리를 사용해 바이트 코드를 조작하는것은 런타임시에 동작.

## 단점

* 기존의 코드를 변경하는 방법은 현재로서는 공식 API가 없음.
    * 롬복은 일종의 해킹으로 공개되지 않은 내부 API를 사용해서 소스코드를 변경.


# 롬복

* 애노테이션 
* 롬복은 표준적이고 반복적으로 작성해야 하는 코드를 애노테이션만 선언하면 개발자 대신 자동으로 생성함.
* 롬복사용을 위해선 Intellij 기준으로 롬복 플러그인과 애노테이션 프로세싱 활성화가 필요. 

## 롬복의 동작 원리

* 컴파일 시점에 애노테이션 프로세서가 끼어들어 특정한 애노테이션이 붙어있는 소스코드를 참조해서 다른 소스코드를 생성.
* 애노테이션이 붙어있는 클래스의 정보를 트리 구조([AST, abstract syntax tree](https://javaparser.org/inspecting-an-ast/))로 참조.

## AST 조작

* AST는 [Processor](https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Processor.html)가 제공하는 API를 통해 참조만 가능하고 수정 불가.
* Processor의 process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) API의 TypeElement와 RoundEnVironment는 참조만 가능하지만 하위 타입중에는 수정이 가능한 타입이 존재.
    * 수정이 가능한 하위 타입으로 타입 캐스팅을 해서 AST를 수정.
    * 공개된 API가 아닌 컴파일러 내부 클래스(내부 API)를 사용해서 소스 코드를 조작.

## 이슈

* 애노테이션 프로세서를 정상적인 방법으로 사용하는것이 아님.
* 공개된 API가 아니고 내부 API를 사용하는것이기 때문에 언제라도 버전에 따라 바뀔수가 있어 버전 호환성 문제 발생 가능성이 높음.
