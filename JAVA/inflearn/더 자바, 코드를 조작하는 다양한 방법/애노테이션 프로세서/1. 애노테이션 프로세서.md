# 애노테이션 프로세서

* 컴파일 단계에서 Annotation에 정의된 프로세스를 동작.
    * 빌드 단계에서 에러 출력 가능.
    * 소스코드나 바이트코드 또는 파일을 생성.
* 여러 라운드에 거쳐 소스 및 컴파일 된 코드를 처리.
* 애노테이션 프로세서 사용의 대표적인 예로 롬복이 있음.

# 롬복

* 롬복은 표준적이고 반복적으로 작성해야 하는 코드를 애노테이션만 선언하면 개발자 대신 자동으로 생성함.
* 롬복사용을 위해선 Intellij 기준으로 롬복 플러그인과 애노테이션 프로세싱 활성화가 필요. 

## 롬복의 동작 원리

* 컴파일 시점에 애노테이션 프로세서가 끼어들어 특정한 애노테이션이 붙어있는 소스코드를 참조해서 다른 소스코드를 생성.
* 애노테이션이 붙어있는 클래스의 정보를 트리 구조([AST, abstract syntax tree](https://javaparser.org/inspecting-an-ast/))로 참조.

## AST 조작

* AST는 [Processor](https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Processor.html)가 제공하는 API를 통해 참조만 가능하고 수정 불가.
* Processor의 process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) API의 TypeElement와 RoundEnVironment는 참조만 가능하지만 하위 타입중에는 수정이 가능한 타입이 존재.
    * 수정이 가능한 하위 타입으로 타입 캐스팅을 해서 AST를 수정.
    * 공개된 API가 아닌 컴파일러 내부 클래스(내부 API)를 사용해서 소스 코드를 조작.

## 이슈

* 애노테이션 프로세서를 정상적인 방법으로 사용하는것이 아님.
* 공개된 API가 아니고 내부 API를 사용하는것이기 때문에 언제라도 버전에 따라 바뀔수가 있어 버전 호환성 문제 발생 가능성이 높음.




