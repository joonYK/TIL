# 컴퓨터 구조

## MIPS 32비트 수치 피연산자

* MIPS 명령어의 길이를 32비트로 고정해서 하드웨어는 간단해졌지만, 명령어에 32비트 상수나 주소를 표시할 수 없음.
* 대체로 상수의 크기는 16비트로 충분하지만 더 큰 상수를 사용할 수 있기때문에 이에 대한 해법이 필요.

### lui(load upper immediate)

* 상위 16비트에 상수를 넣는 명령어.

#### 32비트 상수 로딩 예시

* 0000 0000 0011 1101 0000 1001 0000 0000의 32비트 상수를 레지스터 \$0에 채움.

```
# 상위 16비트(0000 0000 0011 1101, 십진수로 61)를 먼저 채움.
lui $s0, 61

# 레지스터 $s0의 값은 0000 0000 0011 1101 0000 0000 0000 0000이 됨.

# 하위 16비트(0000 1001 0000 0000, 십진수로 2304)를 뒤에 채움.
ori $s0, $s0, 2304
```

### ori(or immediate) 명령어

* 위의 예시에서 사용한 ori는 상수값과 or 연산을 해주는 명령어.

```
ori $s1, $s0, 1200   #1200의 이진수와 $s0을 or 연산한 뒤에 $s1에 저장.
```

#### ori 명령어를 사용한 이유

* addi 명령어는 MSB를 상위 16비트에 복사해서(부호확장) 사용함.
    * 만약 MSB가 1이면 문제가 됨.
* ori는 상위 16비트를 0으로 채움.

### MIPS에서 큰 숫자를 다루는 법.

* 컴파일러나 어셈블러는 큰 숫자를 직접 다룰 수 없어서, 몇 조각으로 나눈 후 레지스터에서 재조립함.
    * 수치 명령어의 상수, 적재나 저장 명령어의 메모리 주소 등.
* 큰 값을 만드는데 사용할 임시 레지스터를 제공함.
    * \$at 레지스터.