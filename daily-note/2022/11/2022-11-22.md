# 컴퓨터 구조

## 명령어 집합

컴퓨터에게 일을 시키려면 그 컴퓨터가 알아먹을 수 있는 언어를 써야한다. 컴퓨터 언어에서 단어를 명령어라 하고 그 어휘를 명령어 집합이라고 한다. 그리고 명령어 집합은 여러개가 존재하긴 하나, 마치 여러 개의 사투리가 존재하는 것처럼 서로 유사하다. 그 중에서 MIPS가 대표적.

## MIPS 산술 연산

### 피연산자는 3개로 고정

MIPS는 산술 명령어는 한 종류의 연산만 지시하고, 변수 3개를 갖는 형식을 엄격히 지킨다. 모든 연산자가 피 연산자를 3개씩 갖도록 설계해서 하드웨어를 단순하게 만든다. 사칙연산같은 경우 2개의 피연산자와 2개의 피연산자로 연산한 결과를 저장할 장소 3개가 필요하다. 만약 변수의 개수가 가변적이면 하드웨어가 복잡해진다.

### 단순한 사칙연산

```
C 언어
a = b + c;
d = a - e;

MIPS 어셈블리 언어
add a, b, c
sub d, a, e
```

### 복잡한 사칙연산

```
C 언어
f = (g + h) - (i + j);

MIPS 어셈블리 언어 (t0, t1은 임시변수)
add t0, g, h    # g+h의 결과를 임시 변수에 저장
add t1, i, j    # i+j의 결과를 임시 변수에 저장
sub f, t0, t1   # 임시 변수에 저장한 결과를 가지고 최종 뺄셈 명령어 실행
```

한 번에 하나의 연산만 가능하기에 여러 개의 어셈블리 명령어로 나뉘어진다.

## 피연산자

### 레지스터

피연산자는 레지스터라는 공간에 저장되어서 연산시에 사용된다. MIPS는 32비트의 레지스터 크기를 가지며, 보통 32비트를 한 덩어리(워드)로 처리한다. 레지스터의 개수는 한정되어서 보통 32개가 존재한다. 그리고 변수에 해당하는 레지스터는 $s0, $1 등으로 표기, 임시 변수는 $t0, $t1 등으로 표기한다.

### 메모리 피연산자

단순 변수 외에 배열이나 구조체 같은 복잡한 자료구조는 메모리에 보관한다. 그래서 메모리에서 레지스터로 데이터를 읽어들이거나 저장하는 명령어가 존재한다.

### 레지스터로 로드

```
C 언어 (A는 100워드 배열)
g = h + A[8]

MIPS 어셈블리 언어
lw $t0, 32($s3)
add $s1, $s2, $t0
```

워드 주소는 4 바이트이기 때문에, 연속된 워드의 주소는 4씩 차이가 난다. 그래서 A 배열의 8번쨰 인덱스는 4바이트 x 8 이므로 32바이트만큼 이동해야 한다. 여기서 32인 상수 부분을 변위(offset)라고 하고, $s3을 베이스 레지스터(base register)라고 한다.

### 메모리에 저장

```
C 언어
A[12] = h + A[8];

MIPS 어셈블리 언어
lw $t0, 32($s3)
add 48($s3), $s2, $t0
```

### 상수 또는 수치 피연산자

상수를 사용시, 메모리에서 상수를 읽어오지 않고 상수를 사용하는 산술 연산 명령어가 존재한다. 상수 필드를 갖는 산술 명령어를 사용해서 매번 메모리에서 상수를 가져오는 것보다 빠르게 연산을 할 수 있다.

```
addi $s3, $s3, 4    # $s3 = $s3 + 4
```

그리고 상수 중에서 0은 또 다른 역할이 있는데, 명령어 집합을 단순하게 만들기 위해 사용하는 경우가 많다. 복사 같은 경우는 피연산자 중 하나가 0인 add 명령어이다. 그래서 MIPS는 레지스터 $zero를 값 0으로 묶어두었다. 쓰이는 빈도가 높기에 전용 레지스터로 만들어 둔 것이다.

## 레지스터 스필링(spilling register)

레지스터의 개수는 부족하고 프로그램에서 사용하는 변수는 많기 때문에 컴파일러는 가능한 자주 사용되는 변수를 레지스터에 넣으려고 한다. 그리고 나머지 변수는 메모리에서 필요할 때 찾아서 사용하는데, 자주 사용하지 않는 변수나 한참 뒤에 사용할 변수를 메모리에 넣는 일을 레지스터 스필링이라고 한다.