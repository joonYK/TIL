# 컴퓨터 구조

## 다른 프로시저를 호출하지 않는 C 프로시저의 컴파일

### C 코드

```c
int leaf_example (int g, int h, int i, int j)
{
    int f;

    f = (g + h) - (i + j);
    return f;
}
```

### MIPS 어셈블리 코드

#### 레지스터 변수

* g, h, i, j = \$a0, \$a1, \$a2, \$a3
* f = \$s0

#### 1. 프로시저가 사용할 레지스터 값 저장

```
addi $sp, $sp, -12  # 스택 영역에 세 개의 레지스터를 저장해놓을 공간을 마련함.
sw  $t1, 8($sp)     # push $t1
sw  $t0, 4($sp)     # push $t0
sw  $s0, 0($sp)     # push $s0
```

* 임시 레지스터 2개를 사용.
* \$s0, \$t0, \$t1
* 세 개의 레지스터에 저장된 기존 값을 스택에 저장해놓음.

#### 2. 연산

```
add $t0, $a0, $a1   # $t0 = g + h
add $t1, $a2, $a3   # $t1 = i + j
add $s0, $t0, $t1   # f = $t0 - $t1
```

#### 3. 계산 결과를 프로시저용 결과 레지스터에 복사

```
add $v0, $s0, $zero   # returns f ($v0 = $s0 + 0)
```

#### 4. 레지스터 원상 복구

* 호출 프로그램으로 되돌아가기 전에 스택에 저장해 두었던 값으로 레지스터를 원상 복구

```
lw  $s0, 0($sp)     # $s0 값 pop
lw  $t0, 4($sp)     # $t0 값 pop
lw  $t1, 8($sp)     # $t1 값 pop
addi $sp, $sp, 12   # 스택 영역 복구
```

#### 5. 복귀 주소 점프

* 프로시저는 복귀 주소를 사용하는 점프 명령(jr)으로 끝남.

```
jr  $ra
```

### 레지스터 스필링 줄이기

* 실제 사용하지 않는 레지스터 값을 쓸데없이 저장했다가 복구하는 일이 생길 수 있음.
* MIPS에서는 레지스터 18개를 두 종류로 나눔.
    * \$t0 ~ \$t9 : 프로시저 호출 시, 피호출 프로그램이 값을 보존해주지 않음.
    * \$s0 ~ \$s7 : 원상 복구 되어야함.
* 따라서 임시 레지스터는 원상 복구할 필요가 없음.