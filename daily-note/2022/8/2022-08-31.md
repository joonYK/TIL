# 오늘 배운 내용 정리

## 트랜잭션 동시성 이슈

여러 트랜잭션에서 하나의 row 데이터에 접근해서 작업할때는 동시성 이슈를 고려해야 한다. 동시에 조회를 하면 모두 같은 데이터를 바라보고 필요한 작업을 하기 때문에 예기치 못한 문제가 발생할 수 있기 때문이다.

예를 들면, 조회수를 차례대로 증가시켜야 하는 상황에서 조회수가 10인 데이터를 2개의 트랜잭션이 동시에 조회했을때, 최종적으로 12가 되기를 바라지만 각 트랜잭션은 10을 1증가시킨 11로 각각 증가시키고 update를 할 것이다. 그래서 최종 카운트는 12가 아닌 11이 된다.

또 하나는 재고시스템을 예로 들 수가 있는데, 재고가 1개 남은 상품을 동시에 여러 트랜잭션이 조회해서 구매하고 재고를 차감할 경우, 다른 트랜잭션에서 먼저 구매해서 상품 재고가 0개가 되어버렸지만 주문이 가능한 상태가 될 수도 있다.

### 1. 비관적 락

DB의 lock을 활용하는 방법이다. 그래서 특정 row 조회시에 수정을 하기 위한 조회라는것을 명시해서 lock을 건다. 그러면 해당 row에 대해 lock을 얻은 트랜잭션이 끝나기 전에는 다른 트랜잭션에서 해당 row에 접근할 수 없다.

#### **sql 사용**

sql 사용시 마지막에 for update 구문을 붙여준다.

```sql
select * from product where id = 1 for update;
```

#### **JPA 사용**

jpa를 사용한다면 repository의 method 위에 @Lock 어노테이션을 붙여준다.

@Lock(LockModeType.PESSIMISTIC_WRITE)

하지만 이 방법들은 락을 잡고있는 시간이 길어지면 다른 트랜잭션들이 그만큼 기다려야하기 때문에 성능상 좋지 않을 수 있다. 꼭 필요한 상황이 아니라면 웬만해선 사용하지 않는것이 좋을것 같다.

#### **Update SQL 사용**

간단하게 조회수를 올릴 목적이라면 update 쿼리를 보내서 DB의 write lock을 얻어서 처리하게 하는 방법을 고려해볼 수 있다.

### 2. 낙관적 락

애플리케이션 레벨에서 동시성 이슈를 처리하는 방법이다. version 컬럼을 추가해서 처리하는 방법인데, row 조회시의 version을 update시에 비교해서 해당 version이 맞으면 update와 함께 version도 같이 올리는 방식이다.

만약 version이 다르다면 이미 다른 트랜잭션에서 수정한것으로 간주하고 실패한다. 그럼 애플리케이션 레벨에서 그에 따라 적절한 처리가 필요한데, 제일 처리가 힘든 부분은 다른 외부환경과의 연동시에 롤백을 처리하는 부분일 것이다. 그래서 외부환경과의 연동이 많을 경우에는 일일히 다시 롤백을 위한 통신을 하거나 낙관적 락 사용을 삼가는것이 좋을것 같다.

하지만 lock을 걸지 않기 때문에 다른 트랜잭션들이 대기해야하는 상황은 벌어지지 않는다.

# 회고

## 아쉬운 점

오늘은 내 자신이 얼마나 나태하고 나약한지에 대해 깨닫는 날인것 같다. 오늘은 어제 공부한 내용에 대해 짧게 복습을하고 모 회사의 채용 프로세스중에 하나인 과제전형을 진행하려고 했다.

하지만 전날에 너무 늦게 잠을 자서 피곤했던지 늦잠을 자버렸다. 그리고 하루종일 피곤한 상태여서 처음 복습을 하는것까지는 성공했으나 집중이 되지않아 다시 잠을잤고 그렇게 시작부터 삐그덕거리니 모든것이 하기 귀찮아지기 시작했다. 

자야할 시간에 제때 자지 않고 피곤한 상태로 한 시간, 두 시간 버티면 그 한시간이 다음날 느끼는 피로도를 배로 증가시키는것 같다. 항상 아쉬운 마음이 들어 핸드폰을 하면서 버티다가 잤는데 그런 습관을 고쳐야겠다.

그리고 오늘 트랜잭션 관련 내용들을 찾아보면서 데이터베이스에 깊게 공부를 해봐야겠다는 생각을 하게 됐다. 백엔드 개발자라는 포지션을 선택하고 앞으로 나아가려고 하는 이상 DB관련된 지식은 필수가 되었다. 클린 아키텍처 공부가 어느정도 끝나면 Real MySQL 이란 책을 사서 공부를 해봐야겠다.