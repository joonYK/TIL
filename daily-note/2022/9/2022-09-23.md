# 대규모 서비스를 지탱하는 기술

## MySQL의 레플리케이션

MySQL은 분산 기능으로 레플리케이션을 지원한다. 레플리케이션은 마스터 서버와 슬레이브 서버들로 구성해서 슬레이브가 마스터의 데이터를 가져가 갱신하는 구조이다. 슬레이브로 조회 쿼리만 보내고, 갱신 쿼리는 마스터로만 보낸다.

### 구조

애플리케이션 서버가 로드밸런서를 통해 슬레이브 서버들로 조회 쿼리를 보낸다. 슬레이브에 갱신 쿼리를 보내면 슬레이브와 마스터간에 데이터를 동기화할 수 없어서, 갱신 쿼리는 꼭 마스터로만 보내야 한다.

중간에 로드밸런서가 아닌 요청을 분배해주는 애플리케이션 서버를 직접 작성해서 배치할 수 있고, MySQL Proxy 같은 기술도 존재한다.

## 마스터/슬레이브의 확장

슬레이브는 참조에만 사용되기 때문에 쉽게 서버를 늘려서 확장할 수 있다. 그러나 갱신계열 쿼리는 데이터 동기화 문제로 인해 확장이 쉽지 않다. 하지만 보통 웹 애플리케이션 요청의 90% 이상이 참조 계열 쿼리이고 갱신 쿼리는 많지 않은 특성으로 인해 마스터 서버에 부하가 갈 일이 많지는 않다.

### 갱신/쓰기계열 확장 시

* 테이블을 분할해서 테이블 크기를 작게 유지.
    * 분할로 인해 쓰기작업 분산.
        * 동일 호스트 내에서 여러 디스크로 분산.
        * 서로 다른 서버로 분산.
* NoSQL 사용 고려.
    * 예를 들어 key-value 저장 방식의 DB.
* 애플리케이션 측면에서 쓰기작업 횟수를 줄일 수 있는지 연구.

## 파티셔닝을 전제로 한 설계

파티셔닝 시에는 테이블 단위로 각 DB서버에 분산할 수 있는데, 이 떄 join 조회를 고려해야 한다. 그 이유는 다른 서버로 분산된 테이블 간에 join 조회를 하기가 힘들기 때문이다.

* 밀접하게 연관된 테이블은 같은 서버에 배치.
* 다른 서버에 분산된 테이블간에는 참조 대상이 되는 테이블의 참조 컬럼을 먼저 조회하고, 다른 테이블에서 in 조회.
* join은 다른 서버로 분산하지 않을거라는 확신이 있을때 사용하는 것이 좋음.

## 파티셔닝의 상반관계

파티셔닝을 적용하면 데이터를 분산해서 서버별 메모리 캐시 효율이 높아지지만 단점도 존재한다. 그리고 파티셔닝은 메모리를 추가하지 못할 때 최후의 수단으로 생각해야 한다.

### 운용의 복잡성

* 각 서버별로 어떤 데이터가 있고 어떤 역할을 하고 있는지를 알아야 함.
    * 서버가 많아지면 많아질수록 체크가 힘듦.
    * 장애가 발생할 경우, 각 서버의 역할을 파악하고 있지 않으면 민첩하게 대응하기가 힘듦.

### 높은 고장률

* 마스터/슬레이브로 분산 시에 마스터 1대, 슬레이브 3대의 분산이 필요.
    * 슬레이브를 2대만 두면, 한 대가 고장나서 슬레이브 추가 도입시에 데이터 복사가 불가.
        * 복사시에 남아있는 슬레이브 1대를 중지하고 복사해야 함.
        * 모든 슬레이브가 죽어서 그 시간동안 조회 질의 응답 불가.
* 서버의 대수가 급격히 늘어나면 그만큼 장애날 수 있는 서버가 많아지는 것이고, 그에 따라 관리 리소스도 증가.
* 만약 서버가 들고있는 데이터가 잠시 서빙하지 않아도 상관없는 데이터라면 3대로도 충분.

# 회고

길고 긴 구직활동이 끝나고 최종적으로 11번가로 입사를 확정짓게 되었다. 또 다시 새로운 곳에서 적응해야 한다는 불안감과 함께 어떤 경험을 하게 될지에 대한 기대감이 같이 느껴진다. 그리고 항상 대용량 트래픽과 데이터를 다뤄보고 싶었는데 11번가는 많은 사용자들이 이용하는 서비스를 제공하기 때문에 이 부분에 대해서 내 갈증을 풀어줄 거라고 생각한다.