# 대규모 서비스를 지탱하는 기술

## 페이지 캐시는 한 번의 read가 필요함

페이지 캐시는 디스크의 데이터를 캐싱하는 것이기 떄문에 최초 한 번의 read가 필요하다. 그런데 만약 서버를 재부팅하게 된다면 기존에 캐싱되어 있던 데이터들이 사라지기 때문에, 이 상태에서 바로 대규모 데이터를 다루는 서버를 서비스 상태로 올린다면 디스크 접근이 필요한 모든 요청에 대해 I/O가 발생할 것이다.

그래서 만약 DB 서버를 재부팅했다면 최초 한 번 DB의 데이터들을 읽어서 캐싱한 이후에 서버의 상태를 운영 환경으로 올리는 것이 좋다.

## 국소성을 고려한 분산

DB 서버의 메모리 캐싱을 더 확보하기 위해 서버를 추가하는데, 데이터 액세스 패턴을 고려해서 데이터를 분산 시키는 방법이 있다. 데이터를 특정 그룹으로 묶어서 각 서버로 분산시킨 다음에 특정 데이터 유형을 검색하는 요청은 해당 서버로 보내는 분배하는 방식이다. 그럼 각 DB 서버는 보유한 데이터 자체가 특정 용도로 집중화되고, 데이터 양 자체도 줄어들기 때문에 서버 전체적으로 보면 메모리에 캐싱되는 데이터가 많아지는 효과가 있다.

### 파티셔닝

국소성을 고려한 분산시에 파티셔닝이라는 방법을 많이 사용한다. 파티셔닝은 DB 서버 한 대를 여러 대의 서버로 분할하는 것이며, 여러 가지 방법이 존재한다. 그 중에서 간단하면서도 많이 사용하는 2가지 방법이 있다.

#### 1. 테이블 단위 분할

간단히 테이블 단위로 DB 서버를 분할하는 것이다. 그래서 보통 함께 검색되는 테이블들을 묶어서 분할하게 된다. 테이블 단위로 분할하게 된다면 특정 테이블 검색에 대한 요청은 해당 DB 서버로 보낼 수 있도로 애플리케이션에서 분배하는 작업이 필요하다.

#### 2. 테이블 데이터 분할

특정 테이블 하나를 여러 테이블로 분할하는 것이다. 예를 들어 사용자의 정보를 저장하고 있는 테이블이 있다고 할 때, 사용자 id의 첫 문자로 파티셔닝을 할 수 있다.

id가 a~c인 사용자는 서버1로, d~f인 사용자는 서버2로 분할하는 방식이다. 그래서 애플리케이션에서 id의 첫 문자를 보고 해당 서버로 분배해주는 처리가 필요하다. 그리고 이 방법은 분할의 단위를 크거나 작게 조절하려고 할 때, 데이터들을 한 번 모아야 한다는 번거로움이 존재한다.

### 요청 패턴에 따라 시스템 분할

용도별로 시스템을 나누는 방법도 존재한다. DB 서버 외에 애플리케이션 서버까지 나누는 방법인데, HTTP 헤더의 User-Agent나 URL 등의 정보를 토대로 일반적 사용자 요청, Google나 Yahoo! 등 봇의 요청, 이미지 등의 특정 요청으로 요청을 각 시스템에 분배하는 방법이다.

