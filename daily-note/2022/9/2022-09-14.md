# 대규모 서비스를 지탱하는 기술

## 대규모 데이터를 다룰 시, 프로그램 작성 요렁

### 1. 최대한 메모리 내에서 계산

어떻게 하면 메모리 내에서 처리를 할 수 있을지를 고민한다. 그 말은 디스크로의 데이터 검색을 최소화하여, 디스크의 느린 속도에 영향을 받지 않도록 하는데 있다.

### 2. 효율적인 알고리즘

1000만 건의 데이터를 단순히 배열에 담아 선형 검색하면 1000만 번 계산을 수행해야 할 수도 있지만, 트리 구조로 이진 검색을 훨씬 더 빠르게 찾을 수 있다.

### 3. 데이터 압축, 검색기술

데이터를 압축해서 데이터의 양을 줄일 수 있다면, 메모리가 부족할 일도 줄어들 것이고 그에 따라 디스크 검색의 횟수도 줄어들 것이다. 그리고 검색시에 DB에만 맡겨서 처리하기가 힘들 때, 특정 용도의 검색엔진을 사용해서 애플리케이션이 이용하도록 하면 더 효율적이다.

## 대규모 데이터를 다루기 전 3대 전제지식

1. OS 캐시
2. 분산을 고려한 RDBMS 운용
3. 알고리즘과 데이터 구조

## CPU 사용율과 I/O 대기율

Load Average는 시스템의 전체 부하상황을 나타내는데, 리눅스의 sar 명령을 이용하면 정확히 CPU의 사용율과 I/O 대기율이 얼마인지 보여준다.

sar 입력시 나오는 지표중에 %user는 사용자 모드에서의 CPU 사용율이고, %system은 시스템 모드에서의 CPU 사용율이다. 

* 사용자 모드 : 일반 사용자 프로그램이 실행되는 모드로 제한적인 명령만 수행.
* 시스템 모드(커널 모드) : OS가 CPU의 제어권을 가지고 운영 체제 코드를 수행, 모든 종류의 명령을 수행 가능.
* 커널 : 운영체제의 핵심으로 시스템의 모든 것을 통제함.
* 프로세스가 실행되는 동안 모드가 계속 변경되면서 실행됨.
    1. 실행 도중에 파일을 읽어야한다고 하면, 시스템 콜을 통해 커널에게 요청.
    2. 시스템 콜의 요청을 받은 커널은 커널 모드로 변경해서 해당 요청을 처리하고 시스템 콜의 리턴값 전달.
    3. 다시 시용자 모드로 전환되고 리턴값을 받아 그 뒤의 로직 수행.

### CPU 코어별 확인

sar에 -P 옵션을 주면 CPU의 코어 별로도 CPU 사용율과 I/O 대기율을 확인할 수 있다. 그런데 한 가지 다른점은 CPU 부하에서는 모든 CPU의 코어가 부하를 나눠갖지만, I/O 디스크가 한 개라면 CPU의 코어가 여러개라도 I/O 작업을 대기중인 CPU는 하나라는 점이다. 즉, 멀티 코어 CPU 환경에서 CPU 부하는 분산되지만 I/O 부하는 분산되지 않는다.